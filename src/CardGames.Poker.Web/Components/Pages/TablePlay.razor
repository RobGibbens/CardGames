@page "/table/{GameId:guid}"
@attribute [Authorize]
@rendermode InteractiveServer
@implements IAsyncDisposable

@using System.ComponentModel
@using CardGames.Contracts.SignalR
@using CardGames.Core.French.Cards
@using CardGames.Poker.Api.Clients
@using CardGames.Poker.Api.Contracts
@using CardGames.Poker.Evaluation
@using CardGames.Poker.Hands.HandTypes
@using CardGames.Poker.Web.Components.Shared
@using CardGames.Poker.Web.Extensions
@using CardGames.Poker.Web.Services
@using Microsoft.AspNetCore.Authorization
@using System.Security.Claims

@inject NavigationManager NavigationManager
@inject IGamesApi GamesApiClient
@inject IGameApiRouter GameApiRouter
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject GameHubClient GameHubClient
@inject DashboardState DashboardState
@inject GameRulesService GameRulesService
@inject ILogger<TablePlay> Logger
@inject ITwosJacksManWithTheAxeApi TwosJacksManWithTheAxeApi
@inject ISevenCardStudApi SevenCardStudApi
@inject IFollowTheQueenApi FollowTheQueenApi
@inject IBaseballApi BaseballApi
@inject IKingsAndLowsApi KingsAndLowsApi
@inject IFiveCardDrawApi FiveCardDrawApiClient

<PageTitle>Table - Friday Night Poker</PageTitle>

<!-- Connection Banner -->
<ConnectionBanner IsConnected="@_isConnected" IsReconnecting="@_isReconnecting" />

<!-- Toast notifications -->
@if (_toastMessages.Count > 0)
{
    <div class="toast-container">
        @foreach (var toast in _toastMessages)
        {
            <div class="toast-notification @toast.Type">
                <span class="toast-message">@toast.Message</span>
            </div>
        }
    </div>
}

<main class="table-play-main">
    <!-- Leave Table / Controls Strip -->
    <div class="table-controls-strip">
        <button class="btn btn-secondary btn-sm leave-table-btn" @onclick="LeaveTableAsync">
            <i class="fa-regular fa-arrow-left"></i>
            Leave Table
        </button>

        @if (_isSeated)
        {
            <button class="btn btn-secondary btn-sm ms-2" @onclick="ToggleSitOutAsync"
                    title="@(IsSittingOut ? "Join the game" : "Sit out next hand")">
                <i class="fa-solid @(IsSittingOut ? "fa-user-check" : "fa-user-clock")"></i>
                @(IsSittingOut ? "I'm Back" : "Sit out next hand")
            </button>
        }

        <div class="table-info-strip">
            <span class="table-name">
                @_gameResponse?.Name
                @if (!string.IsNullOrWhiteSpace(_gameResponse?.GameTypeName))
                {
                    <span class="table-game-type"> (@_gameResponse.GameTypeName)</span>
                }
            </span>
            <span class="table-blinds">
                <span class="table-blinds-pill">
                    <span class="table-blinds-line">Ante: @_ante</span>
                    <span class="table-blinds-line">Min Bet: @_gameResponse?.MinBet</span>
                </span>
            </span>
        </div>

        <div class="table-controls-right">
            @if (!_isLoading)
            {
                if (_isHost)
                {
                    <div class="host-controls">
                        @if
                                        (_gameResponse.CurrentPhase == GamePhase.WaitingForPlayers.ToString() || _gameResponse.CurrentPhase ==
                                        GamePhase.WaitingToStart.ToString())
                        {
                            <a href="/table/@GameId/edit" class="btn btn-secondary btn-sm">
                                <i class="fa-regular fa-pen-to-square"></i>
                                Edit Table
                            </a>
                            <button class="btn btn-primary btn-sm" @onclick="StartGameAsync" disabled="@(!_canStartGame)">
                                <i class="fa-regular fa-play"></i>
                                Start Game
                            </button>
                        }
                        else if (_gameResponse.CurrentPhase != GamePhase.Ended.ToString())
                        {
                            @if (_isPaused)
                            {
                                <button class="btn btn-secondary btn-sm" @onclick="ResumeGameAsync">
                                    <i class="fa-regular fa-play"></i>
                                    Resume
                                </button>
                            }
                            else
                            {
                                <button class="btn btn-secondary btn-sm" @onclick="PauseGameAsync">
                                    <i class="fa-regular fa-pause"></i>
                                    Pause
                                </button>
                            }

                            <button class="btn btn-sm btn-end-game" @onclick="EndGameAsync">
                                <i class="fa-solid fa-octagon"></i>
                                End Game
                            </button>
                        }
                    </div>
                }
            }
            <div class="connection-indicator @(_isConnected ? "connected" : "disconnected")"
                 title="@(_isConnected ? "Connected" : "Disconnected")">
                <span class="connection-dot"></span>
            </div>
        </div>
    </div>

    @if (!_isLoading)
    {
        var temp = "";
        <!-- Main Table Area -->
        <div class="table-play-area">
            <TableCanvas Seats="@_seats" Pot="@_pot" CurrentPhase="@_gameResponse?.CurrentPhase"
                         CurrentPhaseDescription="@_gameResponse?.CurrentPhaseDescription"
                         CurrentActorSeatIndex="@_currentActorSeatIndex" DealerSeatIndex="@_dealerSeatIndex"
                         OnSeatClick="HandleSeatClickAsync" DisableSeatSelectionForCurrentUser="@_isSeated"
                         CurrentPlayerSeatIndex="@_currentPlayerSeatIndex" GameTypeCode="@_gameTypeCode"
                         IsPausedForChipCheck="@_isPausedForChipCheck"
                         FlyingCard="@_flyingCard"
                         HasWildCards="@HasWildCards"
                         WildCards="@GetWildCardsForDisplay()" />

            <!-- Dashboard Panel (left side) -->
            @if (_isSeated)
            {
                <DashboardPanel>
                    <DashboardSection Title="Chips" Icon="fa-solid fa-coins"
                                      IsExpanded="@DashboardState.IsSectionExpanded("Chips")"
                                      IsExpandedChanged="@(value => DashboardState.SetSectionExpanded("Chips", value))">
                        <ChipManagementSection ChipHistory="@_chipHistory" GameId="@GameId"
                                               PlayerId="@(_currentPlayerId ?? Guid.Empty)" GameTypeCode="@_gameResponse?.GameTypeCode"
                                               OnChipsAdded="@OnChipsAddedAsync" />
                    </DashboardSection>

                    <DashboardSection Title="Leaderboard" Icon="fa-solid fa-trophy"
                                      IsExpanded="@DashboardState.IsSectionExpanded("Leaderboard")"
                                      IsExpandedChanged="@(value => DashboardState.SetSectionExpanded("Leaderboard", value))">
                        <LeaderboardSection Players="@GetLeaderboardPlayers()" />
                    </DashboardSection>

                    <DashboardSection Title="Odds" Icon="fa-solid fa-chart-simple"
                                      IsExpanded="@DashboardState.IsSectionExpanded("Odds")"
                                      IsExpandedChanged="@(value => DashboardState.SetSectionExpanded("Odds", value))">
                        <OddsSection HandOdds="@handOdds" />
                    </DashboardSection>

                    <DashboardSection Title="Hand History" Icon="fa-solid fa-clock-rotate-left"
                                      IsExpanded="@DashboardState.IsSectionExpanded("HandHistory")"
                                      IsExpandedChanged="@(value => DashboardState.SetSectionExpanded("HandHistory", value))">
                        <HandHistorySection Entries="@_handHistoryEntries" GameTypeCode="@_gameTypeCode" />
                    </DashboardSection>
                </DashboardPanel>
            }
        </div>

        <!-- Action Panel (only shown when it's player's turn during betting phase and player has cards) -->
        @if (_isPlayerTurn && IsBettingPhase && CurrentPlayerHandCards.Count > 0 && !_dealAnimationInProgress)
        {
            <ActionPanel LegalActions="@_legalActions" MinBet="@_currentMinBet" MaxBet="@_currentMaxBet"
                         CurrentBetToCall="@_currentBetToCall" PlayerChips="@_playerChips"
                         MinRaise="@(_availableActions?.MinRaise ?? _currentMinBet)" OnAction="HandlePlayerActionAsync"
                         IsSubmitting="@_isSubmittingAction" ActionTimer="@_actionTimerState" />
        }

        <!-- Decision Panel (shown during decision phase like Drop/Stay) -->
        <!-- Note: Kings and Lows DropOrStay has its own overlay, so exclude it here -->
        @if (_isPlayerTurn && IsDecisionPhase && !(HasDropOrStay && IsDropOrStayPhase))
        {
            <DecisionPanel Title="@GetDecisionTitle()" Subtitle="@GetDecisionSubtitle()"
                           AvailableActions="@CurrentPhaseAvailableActions" OnDecision="@HandleDecisionAsync"
                           IsSubmitting="@_isSubmittingAction" />
        }

        <!-- Draw Panel (only shown when it's player's turn during draw phase, or forced visible during animation/DrawComplete) -->
        @if
            (((IsDrawingPhase && (_isPlayerDrawTurn || _isPlayerTurn)) || _forceShowDrawPanel || IsDrawCompletePhase) &&
            IsParticipatingInHand)
        {
            <DrawPanel Cards="@_currentPlayerDrawCards" SelectedIndices="@_selectedDiscardIndices"
                       OnToggleSelection="ToggleDiscardSelectionAsync" OnDraw="HandleDrawActionAsync" IsSubmitting="@_isSubmittingDraw"
                       IsAnimating="@_isDrawAnimating" IsDiscarding="@_isDiscardingCards" IsDrawing="@_isDrawingNewCards"
                       CardsDrawn="@_cardsDrawn" NewCardIndices="@_newCardIndices"
                       HandDescription="@(_cardsDrawn && !string.IsNullOrWhiteSpace(_newHandDescription) ? _newHandDescription : currentPlayerHandEvaluationDescription)"
                       MaxDiscards="@GetMaxDiscards()" DrawingSpecialRules="@GetDrawingSpecialRules()"
                       IsReadOnly="@(IsDrawCompletePhase || _cardsDrawn)"
                       ReadOnlyMessage="@(IsDrawCompletePhase ? "Waiting for showdown..." : "New cards drawn!")"
                       ActionTimer="@_actionTimerState" />
        }

        <!-- Draw Phase Waiting Indicator (shown to other players during draw phase) -->
        @if (IsDrawingPhase && !(_isPlayerDrawTurn || _isPlayerTurn) && _currentDrawPlayer is not null)
        {
            <div class="draw-phase-indicator">
                <div class="draw-phase-content">
                    <i class="fa-regular fa-cards fa-spin-pulse"></i>
                    <span>@_currentDrawPlayer.PlayerName is drawing...</span>
                </div>
            </div>
        }

        <!-- Drop or Stay Overlay (for Kings and Lows) -->
        @if (HasDropOrStay && IsDropOrStayPhase && IsParticipatingInHand)
        {
            <DropOrStayOverlay Cards="@_currentPlayerDrawCards" HandDescription="@currentPlayerHandEvaluationDescription"
                               PotAmount="@_pot" HasDecided="@_hasDropOrStayDecided" Decision="@_dropOrStayDecision"
                               IsDeciding="@_isProcessingDropOrStay" PlayersWaiting="@GetPlayersWaitingForDropOrStay()"
                               OnDecision="@HandleDropOrStayDecision" ActionTimer="@_actionTimerState" />
        }

        <!-- Buy Card Overlay (for Baseball) -->
        @if (ShouldShowBuyCardOverlay)
        {
            <BuyCardOverlay TriggerCard="@GetBuyCardTriggerCard()"
                            BuyCardPrice="@_buyCardOffer.BuyCardPrice"
                            PendingOfferCount="@_buyCardOffer.PendingOfferCount"
                            IsSubmitting="@_isProcessingBuyCard"
                            OnDecision="@HandleBuyCardDecisionAsync"
                            ActionTimer="@_actionTimerState" />
        }

        <!-- Player vs Deck Overlay (for Kings and Lows) -->
        @if (IsPlayerVsDeckPhase)
        {
            <PlayerVsDeckOverlay DeckCards="@GetDeckCards()" IsDecisionMaker="@IsCurrentPlayerDeckDecisionMaker"
                                 DecisionMakerName="@GetDeckDecisionMakerName()"
                                 HasDrawn="@(_tableState?.PlayerVsDeck?.HasDeckDrawn ?? _hasDeckDrawn)" IsProcessing="@_isProcessingDeckDraw"
                                 SelectedIndices="@_deckDrawSelectedIndices" OnCardSelectionToggle="@HandleDeckCardSelectionToggle"
                                 OnConfirmDraw="@HandleDeckDrawConfirm" IsAnimating="@_isDeckDrawAnimating"
                                 IsDiscarding="@_isDeckDiscardingCards" IsDrawingNewCards="@_isDeckDrawingNewCards" CardsDrawn="@_deckCardsDrawn"
                                 NewCardIndices="@_deckNewCardIndices" AnimatedCards="@_deckDrawCards" HandDescription="@_deckHandDescription"
                                 StayingPlayerCards="@GetStayingPlayerCards()" StayingPlayerName="@GetStayingPlayerName()"
                                 StayingPlayerHandDescription="@GetStayingPlayerHandDescription()" />
        }

        <!-- Special Phase Overlay (for game-specific phases) -->
        @if (IsSpecialPhase && !ShouldShowBuyCardOverlay)
        {
            <SpecialPhaseOverlay Title="@(_tableState?.CurrentPhaseDescription ?? "Special Phase")"
                                 Description="@GetSpecialPhaseDescription()" IconClass="fa-solid fa-star" />
        }

        <!-- Pot Matching Overlay (for Kings and Lows) -->
        @if (HasPotMatching && IsPotMatchingPhase)
        {
            <PotMatchingOverlay PotAmount="@_pot" LosingPlayers="@GetLosingPlayers()" 
                                IsPlayerAffected="@IsCurrentPlayerLoser"
                                IsLoading="@(_showdownResult is null)"
                                IsSubmitting="@_isAcknowledgingPotMatch"
                                OnAcknowledge="@HandlePotMatchAcknowledge" />
        }

        <!-- Chip Coverage Pause Overlay (shown if paused for chip check and player is short) -->
        @if (_isPausedForChipCheck && IsCurrentPlayerShortOnChips)
        {
            <ChipCoveragePauseOverlay PotAmount="@_chipCheckPotAmount" ShortPlayers="@GetShortPlayers()"
                                      IsCurrentPlayerShort="@IsCurrentPlayerShortOnChips" CurrentPlayerChips="@GetCurrentPlayerChips()"
                                      SecondsRemaining="@GetChipCheckSecondsRemaining()" GameId="@GameId" PlayerId="@(_currentPlayerId ?? Guid.Empty)"
                                      OnChipsAdded="@OnChipsAddedAsync" />
        }

        <!-- Players who are NOT short on chips just see the normal table -->
        <!-- The short player's seat will show "Waiting for chips" status -->

        <!-- Waiting/Pre-game overlay (only when waiting for more players, not when game is ready to start) -->
        @if (_gameResponse.CurrentPhase == GamePhase.WaitingForPlayers.ToString() && (!_isSeated || IsSittingOut ||
            !_isReady))
        {
            <div class="table-overlay waiting-overlay">
                <div class="overlay-content">
                    <div class="overlay-icon"><i class="fa-solid fa-clock"></i></div>
                    <h2>Waiting for Players</h2>

                    <div class="ready-status">
                        @foreach (var seat in _seats.Where(s => s.IsOccupied))
                        {
                            <div class="ready-player @(seat.IsReady ? "is-ready" : "")">
                                <span class="ready-avatar">@GetInitials(seat.PlayerName)</span>
                                <span class="ready-name">@seat.PlayerName</span>
                                @if (seat.IsReady)
                                {
                                    <span class="ready-badge">? Ready</span>
                                }
                            </div>
                        }
                    </div>
                    @if (!_isSeated)
                    {
                        <p class="overlay-hint">Click an empty seat to join the table</p>
                    }
                    else if (!_isReady)
                    {
                        <button class="btn btn-primary btn-lg" @onclick="SetReadyAsync">
                            <i class="fa-regular fa-check"></i>
                            I'm Ready
                        </button>
                    }
                    else
                    {
                        <p class="overlay-hint">Waiting for other players...</p>
                    }
                </div>
            </div>
        }

        <!-- Game Ended overlay -->
        @if (_gameResponse.CurrentPhase == GamePhase.Ended.ToString() && !_showShowdownOverlay)
        {
            <div class="table-overlay ended-overlay">
                <div class="overlay-content">
                    <div class="overlay-icon"><i class="fa-solid fa-circle-xmark"></i></div>
                    <h2>Game Over</h2>
                    <p>Thanks for playing!</p>
                    <div class="final-standings">
                        @foreach (var seat in _seats.Where(s => s.IsOccupied).OrderByDescending(s => s.Chips))
                        {
                            <div class="standing-row">
                                <span class="standing-avatar">@GetInitials(seat.PlayerName)</span>
                                <span class="standing-name">@seat.PlayerName</span>
                                <span class="standing-chips">@seat.Chips.ToString("N0") chips</span>
                            </div>
                        }
                    </div>
                    <button class="btn btn-primary btn-lg" @onclick="LeaveTableAsync">
                        Return to Lobby
                    </button>
                </div>
            </div>
        }

        <!-- Paused overlay -->
        @if (_isPaused && _gameResponse.CurrentPhase != GamePhase.WaitingForPlayers.ToString() && _gameResponse.CurrentPhase
            != GamePhase.Ended.ToString())
        {
            <div class="table-overlay paused-overlay">
                <div class="overlay-content">
                    <div class="overlay-icon"><i class="fa-solid fa-circle-pause"></i></div>
                    <h2>Game Paused</h2>
                    <p>The host has paused the game</p>
                </div>
            </div>
        }

        @* All-In Runout - cards are dealt on table seats with animation, no overlay *@
        @* Animation state is tracked via _runoutAnimationInProgress *@

        @if (
            IsShowdownPhase && _showShowdownOverlay && _showdownResult is not null && !_runoutAnimationInProgress)
        {
            <ShowdownOverlay ShowdownResult="@_showdownResult" ShowdownWon="@_showdownWon" ShowdownLost="@_showdownLost"
                             SecondsUntilNextHand="@_secondsUntilNextHand" IsGameEnded="@IsEndedPhase" OnClose="@CloseShowdownOverlay" />
        }
    }
</main>

@code {
    [Parameter]
    public Guid GameId { get; set; }

    // Connection state (driven by SignalR)
    private bool _isConnected = false;
    private bool _isReconnecting;

    private bool _isLoading = true;

    // Continuous play constants (must match ContinuousPlayBackgroundService)
    private const int ContinuousPlayResultsDisplayDurationSeconds = 8;

    // Table info
    private int _ante = 5;

    // Game state
    private bool _isPaused;
    private int _pot; // TODO: Get from server
    private int _dealerSeatIndex = 0;
    private int _currentActorSeatIndex = -1;

    // Player state
    private bool _isHost; // Determined from game creator
    private bool _isSeated;
    private bool _isReady;
    private bool _hasRequestedLeave;
    private int _currentPlayerSeatIndex = -1;
    private int _playerChips = 100; // TODO: Get from server //TODO:ROB - Set this to 50, or better yet, prompt them first
    private bool _isPlayerTurn;
    private bool _isSubmittingAction;

    private string? _currentPlayerName; // TODO: Get from auth
    private Guid? _currentPlayerId; // Player ID for API calls (hand history, etc.)

    // Action state
    private List<BettingActionType> _legalActions = [];
    private int _currentMinBet;
    private int _currentMaxBet;
    private int _currentBetToCall;

    private AvailableActionsResponse? _availableActions;

    // Action timer state (from SignalR)
    private ActionTimerStateDto? _actionTimerState;

    // Draw phase state
    private bool _isDrawPhase;
    private bool _isPlayerDrawTurn;
    private bool _isSubmittingDraw;
    private bool _isDrawAnimating;
    private bool _isDiscardingCards;
    private bool _isDrawingNewCards;
    private bool _cardsDrawn;
    private List<int> _newCardIndices = [];
    private HashSet<int> _selectedDiscardIndices = [];
    private List<CardInfo> _currentPlayerDrawCards = [];
    private GetCurrentDrawPlayerResponse? _currentDrawPlayer;
    private bool _forceShowDrawPanel;
    private int _maxDiscards = 3;
    private string? _newHandDescription; // Hand description after drawing new cards

    // Kings and Lows specific state
    private bool _hasDropOrStayDecided;
    private string? _dropOrStayDecision;
    private bool _isProcessingDropOrStay;
    private BuyCardOfferPrivateDto? _buyCardOffer;
    private bool _isProcessingBuyCard;
    private bool _hasDeckDrawn;
    private bool _isProcessingDeckDraw;
    private bool _isAcknowledgingPotMatch;
    private HashSet<int> _deckDrawSelectedIndices = new();

    // Chip check pause state (for Kings and Lows)
    private bool _isPausedForChipCheck;
    private DateTimeOffset? _chipCheckPauseEndsAt;
    private int _chipCheckPotAmount;

    // Deck draw animation state
    private bool _isDeckDrawAnimating;
    private bool _isDeckDiscardingCards;
    private bool _isDeckDrawingNewCards;
    private bool _deckCardsDrawn;
    private List<int> _deckNewCardIndices = [];
    private List<CardInfo> _deckDrawCards = [];
    private string? _deckHandDescription;
    private bool _delayShowdownOverlay; // Delay showdown after deck draw animation
    private DateTimeOffset? _showdownDelayUntil; // When the delay expires
    private string? _previousPhaseCategory; // Track phase category for transition detection

    private IReadOnlyList<CardInfo> CurrentPlayerHandCards =>
    _currentPlayerSeatIndex >= 0 && _currentPlayerSeatIndex < _seats.Count
    ? _seats[_currentPlayerSeatIndex].Cards
    : [];

    private string? currentPlayerHandEvaluationDescription =>
    _currentPlayerSeatIndex >= 0 && _currentPlayerSeatIndex < _seats.Count
    ? _seats[_currentPlayerSeatIndex].HandEvaluationDescription
    : null;

    // Showdown state
    private PerformShowdownSuccessful? _showdownResult;
    private bool _showShowdownOverlay;
    private bool _showdownWon;
    private bool _showdownLost;

    // All-In Runout state (for animated card dealing on table seats when all players are all-in)
    private AllInRunoutStateDto? _allInRunoutState;
    private bool _runoutAnimationInProgress;
    private Timer? _runoutDealTimer;
    private int _runoutCurrentStreetIndex; // Which street we're currently dealing (0 = 4th street, etc.)
    private int _runoutCurrentSeatIndex; // Which seat we're dealing to within the current street
    private Dictionary<int, int> _runoutVisibleCardCount = new(); // Seat index -> number of runout cards visible
    private Dictionary<int, int> _runoutInitialCardCounts = new(); // Seat index -> number of cards BEFORE runout started

    // Card Deal Animation state (for Stud/Baseball/Queens)
    private bool _dealAnimationInProgress;
    private Timer? _dealTimer;
    private TableStatePublicDto? _dealTargetState;
    private PrivateStateDto? _dealPendingPrivateState;
    private List<int> _dealOrderedSeatIndices = [];
    private int _dealCurrentCardIndex; // Which card index we are dealing (0, 1, 2 for initial; 3, 4...)
    private int _dealTargetEndIndex; // Stop dealing when _dealCurrentCardIndex reaches this
    private int _dealCurrentSeatIdx; // Index into _dealOrderedSeatIndices
    private Dictionary<int, List<CardInfo>> _dealTargetCards = new(); // SeatIndex -> Full Public Cards list

    // Flying card animation state (visual card flying from deck to player)
    private TableCanvas.FlyingCardInfo? _flyingCard;
    private Timer? _flyingCardTimer;


    // Continuous play state
    private int _secondsUntilNextHand;
    private bool _isResultsPhase;
    private Timer? _countdownTimer;

    // Hand odds state
    private List<HandTypeOddsDto> handOdds = [];

    // Dashboard / Hand history state
    private List<CardGames.Contracts.SignalR.HandHistoryEntryDto> _handHistoryEntries = [];
    private CardGames.Contracts.SignalR.ChipHistoryDto? _chipHistory;
    private int _handNumber = 0;

    // Toast notification state
    private List<ToastMessage> _toastMessages = [];

    private List<SeatInfo> _seats = [];

    private int _seatedPlayerCount;
    private bool _canStartGame;

    private bool _initialized;

    private string? _loggedInUserEmail;

    // Game type code for routing to correct API client
    private string? _gameTypeCode;
    private bool IsTwosJacksManWithTheAxe => string.Equals(_gameTypeCode, "TWOSJACKSMANWITHTHEAXE",
    StringComparison.OrdinalIgnoreCase);
    private bool IsKingsAndLows => string.Equals(_gameTypeCode, "KINGSANDLOWS", StringComparison.OrdinalIgnoreCase);
    private bool IsSevenCardStud => string.Equals(_gameTypeCode, "SEVENCARDSTUD", StringComparison.OrdinalIgnoreCase);
    private bool IsFollowTheQueen => string.Equals(_gameTypeCode, "FOLLOWTHEQUEEN", StringComparison.OrdinalIgnoreCase);
    private bool IsBaseball => string.Equals(_gameTypeCode, "BASEBALL", StringComparison.OrdinalIgnoreCase);

    // Game rules for dynamic UI rendering
    private GetGameRulesResponse? _gameRules;

    // Current table state (from SignalR)
    private TableStatePublicDto? _tableState;

    // Phase category helper properties - driven by SignalR state
    private bool IsBettingPhase =>
    _tableState?.CurrentPhaseCategory?.Equals("Betting", StringComparison.OrdinalIgnoreCase) == true;

    private bool IsDrawingPhase =>
    _tableState?.CurrentPhaseCategory?.Equals("Drawing", StringComparison.OrdinalIgnoreCase) == true
    || _isDrawPhase; // Fallback to existing logic

    private bool IsDecisionPhase =>
    _tableState?.CurrentPhaseCategory?.Equals("Decision", StringComparison.OrdinalIgnoreCase) == true;

    private bool IsSetupPhase =>
    _tableState?.CurrentPhaseCategory?.Equals("Setup", StringComparison.OrdinalIgnoreCase) == true;

    private bool IsResolutionPhase =>
    _tableState?.CurrentPhaseCategory?.Equals("Resolution", StringComparison.OrdinalIgnoreCase) == true;

    private bool IsSpecialPhase =>
    _tableState?.CurrentPhaseCategory?.Equals("Special", StringComparison.OrdinalIgnoreCase) == true;

    private bool IsBuyCardOfferPhase =>
    string.Equals(_tableState?.CurrentPhase, "BuyCardOffer", StringComparison.OrdinalIgnoreCase);

    private bool ShouldShowBuyCardOverlay =>
    IsBuyCardOfferPhase && _buyCardOffer is not null && IsParticipatingInHand;

    // Drop or Stay phase detection (for Kings and Lows)
    private bool IsDropOrStayPhase =>
    string.Equals(_gameResponse?.CurrentPhase, "DropOrStay", StringComparison.OrdinalIgnoreCase);

    // Draw Complete phase detection (for Kings and Lows - delay before showdown)
    private bool IsDrawCompletePhase =>
    string.Equals(_gameResponse?.CurrentPhase, "DrawComplete", StringComparison.OrdinalIgnoreCase);

    // Player vs Deck phase detection (for Kings and Lows)
    private bool IsPlayerVsDeckPhase =>
    string.Equals(_gameResponse?.CurrentPhase, "PlayerVsDeck", StringComparison.OrdinalIgnoreCase);

    // Pot matching phase detection (for Kings and Lows)
    private bool IsPotMatchingPhase =>
    string.Equals(_gameResponse?.CurrentPhase, "PotMatching", StringComparison.OrdinalIgnoreCase);

    // Whether the current player is a loser in pot matching.
    private bool IsCurrentPlayerLoser => _showdownResult?.PlayerHands?.Any(h =>
    (string.Equals(h.PlayerName, _loggedInUserEmail, StringComparison.OrdinalIgnoreCase) ||
    string.Equals(h.PlayerName, _currentPlayerName, StringComparison.OrdinalIgnoreCase)) &&
    h.IsWinner == false) == true;

    // Helper property to check if current player is participating in the current hand
    private bool IsParticipatingInHand =>
    _isSeated &&
    _currentPlayerSeatIndex >= 0 &&
    _currentPlayerSeatIndex < _seats.Count &&
    !_seats[_currentPlayerSeatIndex].IsFolded &&
    (!_seats[_currentPlayerSeatIndex].IsSittingOut || _seats[_currentPlayerSeatIndex].Cards.Count > 0);

    private bool IsSittingOut =>
    _currentPlayerSeatIndex >= 0 &&
    _currentPlayerSeatIndex < _seats.Count &&
    _seats[_currentPlayerSeatIndex].IsSittingOut;

    // Special rules helper properties - driven by SignalR state
    private bool HasWildCards =>
    _tableState?.SpecialRules?.HasWildCards == true;

    private bool HasSevensSplit =>
    _tableState?.SpecialRules?.HasSevensSplit == true;

    private bool HasDropOrStay =>
    _tableState?.SpecialRules?.HasDropOrStay == true;

    private bool HasPotMatching =>
    _tableState?.SpecialRules?.HasPotMatching == true;

    // Get available actions for current phase
    private IReadOnlyList<string> CurrentPhaseAvailableActions =>
    _tableState?.CurrentPhaseAvailableActions ?? [];

    private bool IsCompletePhase => string.Equals(_gameResponse?.CurrentPhase, "Complete",
    StringComparison.OrdinalIgnoreCase);

    private bool IsEndedPhase => string.Equals(_gameResponse?.CurrentPhase, GamePhase.Ended.ToString(),
    StringComparison.OrdinalIgnoreCase);

    private bool IsShowdownPhase => string.Equals(_gameResponse?.CurrentPhase, GamePhase.Showdown.ToString(),
    StringComparison.OrdinalIgnoreCase)
    || string.Equals(_gameResponse?.CurrentPhase, "Showdown", StringComparison.OrdinalIgnoreCase)
    || IsPotMatchingPhase
    || IsCompletePhase
    || IsEndedPhase;

    protected override async Task OnInitializedAsync()
    {
        if (_initialized)
        {
            return;
        }

        _initialized = true;
        InitializeSeats();

        // Subscribe to SignalR events
        GameHubClient.OnTableStateUpdated += HandleTableStateUpdatedAsync;
        GameHubClient.OnPrivateStateUpdated += HandlePrivateStateUpdatedAsync;
        GameHubClient.OnPlayerJoined += HandlePlayerJoinedAsync;
        GameHubClient.OnConnectionStateChanged += HandleConnectionStateChanged;
        GameHubClient.OnActionTimerUpdated += HandleActionTimerUpdatedAsync;
        GameHubClient.OnPlayerActionPerformed += HandlePlayerActionPerformedAsync;

        // Load initial data FIRST so seats and _gameResponse are populated
        // before SignalR sends its state snapshot
        await LoadDataAsync();

        // Connect to SignalR hub and join game - the snapshot will now
        // be processed correctly since seats are already populated
        await ConnectAndJoinGameAsync();
    }

    private async Task ConnectAndJoinGameAsync()
    {
        try
        {
            await GameHubClient.ConnectAsync();
            _isConnected = GameHubClient.IsConnected;
            await GameHubClient.JoinGameAsync(GameId);
            Logger.LogInformation("Connected to SignalR and joined game {GameId}", GameId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to connect to SignalR hub for game {GameId}", GameId);
            _isConnected = false;
        }
    }

    private void HandleConnectionStateChanged(Microsoft.AspNetCore.SignalR.Client.HubConnectionState state)
    {
        _isConnected = state == Microsoft.AspNetCore.SignalR.Client.HubConnectionState.Connected;
        _isReconnecting = state == Microsoft.AspNetCore.SignalR.Client.HubConnectionState.Reconnecting;
        _ = InvokeAsync(StateHasChanged);
    }

    private async Task HandlePlayerJoinedAsync(PlayerJoinedDto notification)
    {
        if (notification.GameId != GameId)
        {
            return;
        }

        Logger.LogDebug("Player {PlayerName} joined at seat {SeatIndex}", notification.PlayerName, notification.SeatIndex);

        // Show toast notification to other players
        await ShowToastAsync(notification.Message, "info");
    }

    private async Task ShowToastAsync(string message, string type = "info", int durationMs = 4000)
    {
        var toast = new ToastMessage(message, type);
        _toastMessages.Add(toast);
        await InvokeAsync(StateHasChanged);

        // Auto-dismiss after duration
        _ = Task.Run(async () =>
        {
            await Task.Delay(durationMs);
            _toastMessages.Remove(toast);
            await InvokeAsync(StateHasChanged);
        });
    }

    private async Task HandleTableStateUpdatedAsync(TableStatePublicDto state)
    {
        if (state.GameId != GameId)
        {
            return;
        }

        Logger.LogDebug("Received table state update for game {GameId}, phase: {Phase}", state.GameId, state.CurrentPhase);

        // Store the table state for phase category checks
        _tableState = state;

        if (_dealAnimationInProgress)
        {
            _dealTargetState = state;
        }

        // Update deck hand description from state
        if (state.PlayerVsDeck is not null)
        {
            _deckHandDescription = state.PlayerVsDeck.DeckHandDescription;
        }

        // Update game type code for routing to correct API
        if (!string.IsNullOrWhiteSpace(state.GameTypeCode))
        {
            _gameTypeCode = state.GameTypeCode;

            // Load game rules if not already loaded
            if (_gameRules is null && !string.IsNullOrWhiteSpace(_gameTypeCode))
            {
                _gameRules = await GameRulesService.GetGameRulesAsync(_gameTypeCode);
            }
        }

        // Update game response fields from public state
        // Handle case where _gameResponse is not yet loaded from API
        if (_gameResponse is not null)
        {
            var previousHandNumber = _gameResponse.CurrentHandNumber;
            var previousPhase = _gameResponse.CurrentPhase;

            _gameResponse = _gameResponse with
            {
                CurrentPhase = state.CurrentPhase,
                CurrentPhaseDescription = state?.CurrentPhaseDescription ?? "",
                Name = state.Name ?? _gameResponse.Name,
                GameTypeName = state.GameTypeName ?? _gameResponse.GameTypeName,
                Ante = state.Ante,
                MinBet = state.MinBet,
                DealerPosition = state.DealerSeatIndex,
                CurrentPlayerIndex = state.CurrentActorSeatIndex,
                CurrentHandNumber = state.CurrentHandNumber
            };

            _ante = state.Ante;
            _pot = state.TotalPot;
            _dealerSeatIndex = state.DealerSeatIndex;
            _currentActorSeatIndex = state.CurrentActorSeatIndex;
            _isPaused = state.IsPaused;

            // Update chip check pause state (for Kings and Lows)
            if (state.ChipCheckPause is not null)
            {
                _isPausedForChipCheck = state.ChipCheckPause.IsPaused;
                _chipCheckPauseEndsAt = state.ChipCheckPause.PauseEndsAt;
                _chipCheckPotAmount = state.ChipCheckPause.PotAmountToCover;
            }
            else
            {
                _isPausedForChipCheck = false;
                _chipCheckPauseEndsAt = null;
                _chipCheckPotAmount = 0;
            }

            // Clean up old hand cards when starting a new hand to ensure animations work correctly
            if (state.CurrentHandNumber != previousHandNumber)
            {
                foreach (var s in _seats)
                {
                    s.Cards = [];
                    s.HandEvaluationDescription = null;
                }
            }

            // Check for Card Deal Animation trigger (Stud/Baseball/Queens)
            // Detect ANY increase in cards for active players
            var isStudGame = IsSevenCardStud || IsBaseball || IsFollowTheQueen;
            if (isStudGame && !_dealAnimationInProgress && !_runoutAnimationInProgress)
            {
                // Identify active players who are not folded in the NEW state (since if folded, they don't get new cards)
                var activeSeatIndices = _seats
                    .Where(s => s.IsOccupied && !s.IsSittingOut)
                    .Select(s => s.SeatIndex)
                    .ToList();

                if (activeSeatIndices.Count > 0)
                {
                    // Find a player who is active in both states and check if their card count increased
                    foreach (var seatIdx in activeSeatIndices)
                    {
                        var currentSeat = _seats.FirstOrDefault(s => s.SeatIndex == seatIdx);
                        var newSeat = state.Seats.FirstOrDefault(s => s.SeatIndex == seatIdx);

                        // Only consider non-folded players in the new state (folded players stop receiving cards)
                        // Exception: Initial deal (current count 0) everyone gets cards even if technically not "folded" yet
                        if (currentSeat != null && newSeat != null && !newSeat.IsFolded)
                        {
                            var currentCount = currentSeat.Cards.Count;
                            var newCount = newSeat.Cards.Count;

                            if (newCount > currentCount)
                            {
                                // Trigger animation for the difference
                                StartCardDealAnimation(state, currentCount, newCount - currentCount);
                                break; // Only trigger once
                            }
                        }
                    }
                }
            }

            // IMPORTANT: Check for All-In Runout BEFORE updating seats
            // This ensures we capture initial card counts and set the animation flag
            // before UpdateSeatsFromPublicState would overwrite cards with full runout cards
            if (state.AllInRunout is not null && state.AllInRunout.IsActive && !_runoutAnimationInProgress)
            {
                _allInRunoutState = state.AllInRunout;

                // Capture the initial card count for each seat BEFORE the runout cards are added
                // This is the number of cards dealt before everyone went all-in
                _runoutInitialCardCounts.Clear();
                foreach (var seatIndex in state.AllInRunout.RunoutCardsBySeat?.Keys ?? [])
                {
                    if (seatIndex >= 0 && seatIndex < _seats.Count && _seats[seatIndex].IsOccupied)
                    {
                        _runoutInitialCardCounts[seatIndex] = _seats[seatIndex].Cards.Count;
                    }
                }

                // Set the animation flag BEFORE UpdateSeatsFromPublicState
                _runoutAnimationInProgress = true;
                _runoutCurrentStreetIndex = 0;
                _runoutCurrentSeatIndex = 0;
                _runoutVisibleCardCount.Clear();

                // Initialize visible runout card count to 0 for each seat
                foreach (var seatIndex in state.AllInRunout.RunoutCardsBySeat?.Keys ?? [])
                {
                    _runoutVisibleCardCount[seatIndex] = 0;
                }

                Logger.LogInformation("Detected all-in runout for game {GameId}, starting table animation", state.GameId);
            }

            // Update seats from public state
            // Note: If _runoutAnimationInProgress is true, this will preserve cards for runout seats
            UpdateSeatsFromPublicState(state.Seats);

            // Start the runout timer AFTER UpdateSeatsFromPublicState (if we just detected runout)
            if (_runoutAnimationInProgress && _runoutDealTimer is null)
            {
                // Start the timer to deal cards one by one (2 second delay before first card)
                _runoutDealTimer = new Timer(DealNextRunoutCard, null, TimeSpan.FromSeconds(2), Timeout.InfiniteTimeSpan);
            }

            // Update previous phase category for next state update
            var currentPhaseCategory = state.CurrentPhaseCategory;
            _previousPhaseCategory = currentPhaseCategory;

            // Handle continuous play state transitions
            var isStartPhase = state.CurrentPhase == "CollectingAntes" || state.CurrentPhase == "Dealing" ||
            state.CurrentPhase == "DropOrStay" || state.CurrentPhase == "WaitingForPlayers";

            var wasStartPhase = previousPhase == "CollectingAntes" || previousPhase == "Dealing" ||
            previousPhase == "DropOrStay" || previousPhase == "WaitingForPlayers";

            var handChanged = state.CurrentHandNumber != previousHandNumber;

            // Handle showdown state - check if entering showdown/complete phase
            // Pass whether we should delay showing the overlay (only for deck draw animation now)
            var shouldDelayShowdownOverlay = _delayShowdownOverlay ||
            (_showdownDelayUntil.HasValue && DateTimeOffset.UtcNow < _showdownDelayUntil.Value);

            // If runout animation is in progress, delay the showdown
            if (_runoutAnimationInProgress)
            {
                shouldDelayShowdownOverlay = true;
            }

            if (state.Showdown is not null)
            {
                UpdateShowdownFromPublicState(state.Showdown, shouldDelayShowdownOverlay || _runoutAnimationInProgress);
            }

            // If entering showdown or complete phase, load showdown results via API
            // But delay if we're showing the all-in runout animation
            if (IsShowdownPhase && _showdownResult is null && !shouldDelayShowdownOverlay && !_runoutAnimationInProgress)
            {
                await TryLoadShowdownAsync();
            }

            // If deck just finished drawing (via SignalR update from another player's action),
            // set a delay for showing the showdown overlay
            if (state.PlayerVsDeck?.HasDeckDrawn == true && !_hasDeckDrawn && !_showdownDelayUntil.HasValue &&
            !IsCurrentPlayerDeckDecisionMaker)
            {
                // Non-decision maker: delay showdown overlay by 5 seconds to let them see the animation
                _showdownDelayUntil = DateTimeOffset.UtcNow.AddSeconds(5);
                _hasDeckDrawn = true;

                // Schedule the showdown to appear after delay
                _ = Task.Run(async () =>
                {
                    await Task.Delay(TimeSpan.FromSeconds(5));
                    _showdownDelayUntil = null;
                    // Load showdown results if not already loaded, then show the overlay
                    if (_showdownResult is null && IsShowdownPhase)
                    {
                        await TryLoadShowdownAsync();
                    }
                    _showShowdownOverlay = true;
                    await InvokeAsync(StateHasChanged);
                });
            }

            // Handle continuous play countdown
            _isResultsPhase = state.IsResultsPhase;

            if (IsEndedPhase)
            {
                // If game ended, enforce a local countdown if none exists
                if (_secondsUntilNextHand <= 0 && _countdownTimer is null)
                {
                    _secondsUntilNextHand = 10;
                }
            }
            else
            {
                // Prefer server value if provided
                if (state.SecondsUntilNextHand.HasValue && state.SecondsUntilNextHand.Value > 0)
                {
                    _secondsUntilNextHand = state.SecondsUntilNextHand.Value;
                }
                // Fallback to local countdown if overlay is visible and we have time left
                else if (_showShowdownOverlay && _secondsUntilNextHand > 0)
                {
                    // Keep local value
                }
                // Initialize local countdown if overlay is shown (and we have results) but no time set
                // This handles cases where SignalR populates the showdown but sends no countdown
                else if (_showShowdownOverlay && _showdownResult is not null)
                {
                    _secondsUntilNextHand = ContinuousPlayResultsDisplayDurationSeconds;
                }
                else
                {
                    _secondsUntilNextHand = 0;
                }
            }

            // Keep timer running if we have a local countdown
            bool keepLocalTimerRunning = _showShowdownOverlay && _secondsUntilNextHand > 0;

            if ((_isResultsPhase || IsEndedPhase || keepLocalTimerRunning) && _secondsUntilNextHand > 0)
            {
                StartCountdownTimer();
            }
            else if (!_isResultsPhase && !IsEndedPhase && !keepLocalTimerRunning)
            {
                StopCountdownTimer();
                // Clear showdown overlay when new hand starts
                if (!IsShowdownPhase)
                {
                    _showShowdownOverlay = false;
                    _showdownResult = null;

                    // Only reset game state if we are truly starting a new hand (Setup/Dealing phases)
                    // This prevents UI state (like visible cards during draw delay) from being cleared
                    // just because a SignalR update arrived for a subsequent phase like SecondBettingRound
                    var isNewHand = state.CurrentPhaseCategory?.Equals("Setup", StringComparison.OrdinalIgnoreCase) == true;

                    if (isNewHand || (isStartPhase && !wasStartPhase) || handChanged)
                    {
                        isNewHand = true;
                    }
                    else
                    {
                        isNewHand = false;
                    }

                    if (isNewHand)
                    {
                        // Reset Kings and Lows specific state for new hand
                        _hasDropOrStayDecided = false;
                        _dropOrStayDecision = null;
                        _hasDeckDrawn = false;
                        _deckHandDescription = null;
                        _deckDrawSelectedIndices.Clear();
                        _delayShowdownOverlay = false;
                        _showdownDelayUntil = null;
                        _previousPhaseCategory = null;
                        _isAcknowledgingPotMatch = false;

                        // Reset All-In Runout state for new hand
                        _allInRunoutState = null;
                        _runoutAnimationInProgress = false;
                        _runoutDealTimer?.Dispose();
                        _runoutDealTimer = null;
                        _runoutCurrentStreetIndex = 0;
                        _runoutCurrentSeatIndex = 0;
                        _runoutVisibleCardCount.Clear();
                        _runoutInitialCardCounts.Clear();

                        // Reset DrawPanel state for new hand
                        _selectedDiscardIndices.Clear();
                        _currentPlayerDrawCards = [];
                        _cardsDrawn = false;
                        _newHandDescription = null;
                        _isPlayerDrawTurn = false;
                        _isDrawAnimating = false;
                        _isDiscardingCards = false;
                        _isDrawingNewCards = false;
                        _isSubmittingDraw = false;
                        _forceShowDrawPanel = false;
                        _newCardIndices = [];
                    }
                }
            }
        }
        else
        {
            // SignalR update arrived before LoadDataAsync completed - defer to initial load
            Logger.LogDebug("Received SignalR update before initial data loaded, skipping state update");
            return;
        }

        // Update phase-dependent state
        _isDrawPhase = state.CurrentPhase == "DrawPhase";

        // Note: Hand history is now updated from private state (HandlePrivateStateUpdatedAsync)
        // because it contains complete player results for all participants in each hand

        // Recalculate derived state
        _seatedPlayerCount = _seats.Count(s => s.IsOccupied);
        var activePlayers = _seats.Where(s => s.IsOccupied && !s.IsSittingOut);
        _canStartGame = activePlayers.Count() >= (_gameResponse?.MinimumNumberOfPlayers ?? 2) &&
        activePlayers.All(s => s.IsReady);

        // Update current player info
        _currentPlayerSeatIndex = _seats.FirstOrDefault(s => s.IsOccupied &&
        !string.IsNullOrWhiteSpace(_loggedInUserEmail) &&
        string.Equals(s.PlayerName, _loggedInUserEmail, StringComparison.OrdinalIgnoreCase))?.SeatIndex ?? -1;

        _isSeated = _currentPlayerSeatIndex >= 0;
        _isReady = _isSeated && _seats[_currentPlayerSeatIndex].IsReady;

        // Redirect if the player requested to leave and is no longer seated (hand completed)
        if (_hasRequestedLeave && !_isSeated)
        {
            _hasRequestedLeave = false;
            await GameHubClient.LeaveGameAsync(GameId);
            NavigationManager.NavigateTo("/lobby");
            return;
        }

        await InvokeAsync(StateHasChanged);
    }

    private async Task HandlePrivateStateUpdatedAsync(PrivateStateDto state)
    {
        if (state.GameId != GameId)
        {
            return;
        }

        Logger.LogDebug("Received private state update for player {PlayerName} at seat {SeatPosition}",
        state.PlayerName, state.SeatPosition);

        // Use the seat position from private state as the authoritative source.
        // This is more reliable than name matching since the server knows the exact seat.
        var targetSeatIndex = state.SeatPosition;

        // Update currentPlayerSeatIndex if not set or if it differs from the authoritative position
        if (_currentPlayerSeatIndex < 0 || _currentPlayerSeatIndex != targetSeatIndex)
        {
            _currentPlayerSeatIndex = targetSeatIndex;
            _currentPlayerName = state.PlayerName;
            _isSeated = true;

            // Mark the correct seat as current player
            if (targetSeatIndex >= 0 && targetSeatIndex < _seats.Count)
            {
                _seats[targetSeatIndex].IsCurrentPlayer = true;
            }
        }

        // Update player's cards using the authoritative seat position
        // Always update cards from private state - even if empty (player is sitting out or between hands)
        // BUT: Skip card updates during runout animation - the animation controls card visibility
        if (targetSeatIndex >= 0 && targetSeatIndex < _seats.Count)
        {
            var isInRunoutAnimation = _runoutAnimationInProgress &&
            _allInRunoutState?.RunoutCardsBySeat?.ContainsKey(targetSeatIndex) == true;

            if (isInRunoutAnimation || _dealAnimationInProgress)
            {
                Logger.LogDebug(
                "Skipping private state card update for seat {SeatIndex} during animation (Runout={Runout}, Deal={Deal})",
                targetSeatIndex, isInRunoutAnimation, _dealAnimationInProgress);

                if (_dealAnimationInProgress && state.Hand is { Count: > 0 })
                {
                    _dealPendingPrivateState = state;
                }
            }
            else if (state.Hand is { Count: > 0 })
            {
                Logger.LogInformation(
                "Updating seat {SeatIndex} cards from private state: {CardCount} cards, first card: {FirstCard}",
                targetSeatIndex,
                state.Hand.Count,
                $"{state.Hand[0].Rank} of {state.Hand[0].Suit}");

                _seats[targetSeatIndex].Cards = state.Hand.Select(c => new CardInfo
                {
                    Rank = c.Rank,
                    Suit = c.Suit,
                    IsFaceUp = true,
                    IsPubliclyVisible = c.IsPubliclyVisible,
                    IsSelected = false,
                    DealOrder = c.DealOrder,
                    IsWild = IsWildCard(c.Rank, c.Suit)
                }).ToList();

                _seats[targetSeatIndex].HandEvaluationDescription = state.HandEvaluationDescription;
            }
            else
            {
                // Clear cards when hand is empty (player is sitting out or new hand hasn't dealt yet)
                Logger.LogInformation(
                "Clearing seat {SeatIndex} cards from private state: Hand is empty",
                targetSeatIndex);

                _seats[targetSeatIndex].Cards = [];
                _seats[targetSeatIndex].HandEvaluationDescription = null;
            }

            _seats[targetSeatIndex].IsCurrentPlayer = true;
        }

        // Update available actions
        if (state.AvailableActions is not null)
        {
            _availableActions = new AvailableActionsResponse(
            callAmount: state.AvailableActions.CallAmount,
            canAllIn: state.AvailableActions.CanAllIn,
            canBet: state.AvailableActions.CanBet,
            canCall: state.AvailableActions.CanCall,
            canCheck: state.AvailableActions.CanCheck,
            canFold: state.AvailableActions.CanFold,
            canRaise: state.AvailableActions.CanRaise,
            maxBet: state.AvailableActions.MaxBet,
            minBet: state.AvailableActions.MinBet,
            minRaise: state.AvailableActions.MinRaise
            );

            _isPlayerTurn = state.IsMyTurn;
            if (state.IsMyTurn)
            {
                _legalActions = MapLegalActionsFromPrivateState(state.AvailableActions);
                _currentMinBet = Math.Max(_gameResponse?.MinBet ?? 0, state.AvailableActions.MinBet);
                _currentMaxBet = state.AvailableActions.MaxBet;
                _currentBetToCall = state.AvailableActions.CallAmount;
            }
        }
        else
        {
            _isPlayerTurn = state.IsMyTurn && _isDrawPhase; // May be draw turn
            if (!_isDrawPhase)
            {
                _legalActions = [];
            }
        }

        // Update draw phase state
        if (state.Draw is not null)
        {
            _isPlayerDrawTurn = state.Draw.IsMyTurnToDraw;
            _maxDiscards = state.Draw.MaxDiscards;

            // Sync local drawing state with server truth, but preserve local animation state
            if (!_isDrawAnimating && !_isSubmittingDraw)
            {
                _cardsDrawn = state.Draw.HasDrawnThisRound;
            }

            if (state.Draw.IsMyTurnToDraw && !_isDrawAnimating && !_forceShowDrawPanel)
            {
                _currentPlayerDrawCards = state.Hand.Select((c, i) => new CardInfo
                {
                    Rank = c.Rank,
                    Suit = c.Suit,
                    IsFaceUp = true,
                    IsSelected = _selectedDiscardIndices.Contains(i)
                }).ToList();
            }
            else if ((_isDrawAnimating || _forceShowDrawPanel) && _currentPlayerDrawCards.Count == 0)
            {
                // Preserve whatever is currently being animated. If we lost the list for any reason,
                // fall back to the latest private hand state to keep the panel populated.
                _currentPlayerDrawCards = state.Hand.Select((c, i) => new CardInfo
                {
                    Rank = c.Rank,
                    Suit = c.Suit,
                    IsFaceUp = true,
                    IsSelected = _selectedDiscardIndices.Contains(i)
                }).ToList();
            }
        }
        else if (IsDrawingPhase)
        {
            // Sync with general turn flag in drawing phase if draw-specific data is missing (common for sitting out players)
            _isPlayerDrawTurn = state.IsMyTurn;

            // Ensure DrawPanel has cards if it's the player's turn to draw but state.Draw was null
            if (_isPlayerDrawTurn && !_isDrawAnimating && !_forceShowDrawPanel && _currentPlayerDrawCards.Count == 0 && state.Hand
            is not null)
            {
                _currentPlayerDrawCards = state.Hand.Select((c, i) => new CardInfo
                {
                    Rank = c.Rank,
                    Suit = c.Suit,
                    IsFaceUp = true,
                    IsSelected = _selectedDiscardIndices.Contains(i)
                }).ToList();
            }
        }

        // Update Drop or Stay phase state (Kings and Lows)
        if (state.DropOrStay is not null)
        {
            _hasDropOrStayDecided = state.DropOrStay.HasDecidedThisRound;
            _dropOrStayDecision = state.DropOrStay.Decision;
        }

        _buyCardOffer = state.BuyCardOffer;

        // Populate cards for display in DropOrStayOverlay
        // Check both the property AND the phase string directly from state to handle reconnection scenarios
        // where _gameResponse might not be populated yet
        var currentPhase = _gameResponse?.CurrentPhase ?? string.Empty;
        if ((IsDropOrStayPhase || string.Equals(currentPhase, "DropOrStay", StringComparison.OrdinalIgnoreCase))
        && state.Hand is not null && state.Hand.Count > 0)
        {
            _currentPlayerDrawCards = state.Hand.Select((c, i) => new CardInfo
            {
                Rank = c.Rank,
                Suit = c.Suit,
                IsFaceUp = true,
                IsSelected = false
            }).ToList();
        }
        // Also populate cards for PlayerVsDeck phase when reconnection
        // This ensures the player can see the deck cards after reconnection
        else if ((IsPlayerVsDeckPhase || string.Equals(currentPhase, "PlayerVsDeck", StringComparison.OrdinalIgnoreCase))
        && state.Hand is not null && state.Hand.Count > 0 && _currentPlayerDrawCards.Count == 0)
        {
            // Populate player's own cards for reference during player-vs-deck phase
            _currentPlayerDrawCards = state.Hand.Select((c, i) => new CardInfo
            {
                Rank = c.Rank,
                Suit = c.Suit,
                IsFaceUp = true,
                IsSelected = false
            }).ToList();
        }
        // Populate cards for DrawComplete phase so all players can see their new hands
        else if ((IsDrawCompletePhase || string.Equals(currentPhase, "DrawComplete", StringComparison.OrdinalIgnoreCase))
        && state.Hand is not null && state.Hand.Count > 0)
        {
            // Show the player's new hand during DrawComplete phase
            _currentPlayerDrawCards = state.Hand.Select((c, i) => new CardInfo
            {
                Rank = c.Rank,
                Suit = c.Suit,
                IsFaceUp = true,
                IsSelected = false
            }).ToList();
        }

        // Calculate hand odds from current cards
        CalculateHandOdds(state.Hand);

        // Update hand history from private state (contains personalized player results)
        if (state.HandHistory is not null && state.HandHistory.Count > 0)
        {
            _handHistoryEntries = state.HandHistory.ToList();
        }

        // Update chip history from private state
        if (state.ChipHistory is not null)
        {
            _chipHistory = state.ChipHistory;
        }

        await InvokeAsync(StateHasChanged);
    }

    private void UpdateSeatsFromPublicState(IReadOnlyList<SeatPublicDto> publicSeats)
    {
        Logger.LogDebug("UpdateSeatsFromPublicState: Processing {SeatCount} seats, runoutAnimationInProgress={RunoutInProgress}",
        publicSeats.Count, _runoutAnimationInProgress);

        var updatedSeatIndices = new HashSet<int>();

        foreach (var publicSeat in publicSeats)
        {
            if (publicSeat.SeatIndex >= 0 && publicSeat.SeatIndex < _seats.Count)
            {
                updatedSeatIndices.Add(publicSeat.SeatIndex);

                // Check if this is the current player by multiple criteria:
                // 1. Email match (primary)
                // 2. Seat index match (for when Player.Name differs from email)
                // 3. Player name match against currentPlayerName (set from private state)
                var isCurrentPlayerByEmail = !string.IsNullOrWhiteSpace(_loggedInUserEmail) &&
                string.Equals(publicSeat.PlayerName, _loggedInUserEmail, StringComparison.OrdinalIgnoreCase);
                var isCurrentPlayerBySeatIndex = _currentPlayerSeatIndex >= 0 &&
                publicSeat.SeatIndex == _currentPlayerSeatIndex;
                var isCurrentPlayerByName = !string.IsNullOrWhiteSpace(_currentPlayerName) &&
                string.Equals(publicSeat.PlayerName, _currentPlayerName, StringComparison.OrdinalIgnoreCase);
                var isCurrentPlayer = isCurrentPlayerByEmail || isCurrentPlayerBySeatIndex || isCurrentPlayerByName;

                // Check if this seat is part of the runout animation
                var isInRunoutAnimation = _runoutAnimationInProgress &&
                _allInRunoutState?.RunoutCardsBySeat?.ContainsKey(publicSeat.SeatIndex) == true;

                // Preserve face-up cards for current player (will be updated by private state)
                // This prevents briefly showing face-down cards before private state arrives
                // BUT: Don't preserve cards if the player is sitting out (they shouldn't have cards)
                // ALSO: Preserve cards during runout animation - the animation controls card visibility
                // ALSO: Preserve cards during initial deal animation - the animation controls card visibility
                var existingCards = _seats[publicSeat.SeatIndex].Cards;
                var shouldPreserveCards = (isCurrentPlayer && existingCards.Any(c => c.IsFaceUp) && !publicSeat.IsSittingOut)
                || isInRunoutAnimation
                || _dealAnimationInProgress;

                Logger.LogDebug(
                "UpdateSeatsFromPublicState: Seat {SeatIndex}, PlayerName={PlayerName}, " +
                "isCurrentPlayerByEmail={ByEmail}, isCurrentPlayerBySeatIndex={BySeat}, " +
                "isCurrentPlayerByName={ByName}, existingCards={ExistingCount}, " +
                "existingFaceUp={FaceUpCount}, shouldPreserve={ShouldPreserve}, publicCardCount={PublicCount}, isSittingOut={IsSittingOut}, isInRunout={IsInRunout}, isDealAnim={IsDealAnim}",
                publicSeat.SeatIndex, publicSeat.PlayerName,
                isCurrentPlayerByEmail, isCurrentPlayerBySeatIndex, isCurrentPlayerByName,
                existingCards.Count, existingCards.Count(c => c.IsFaceUp),
                shouldPreserveCards, publicSeat.Cards.Count, publicSeat.IsSittingOut, isInRunoutAnimation, _dealAnimationInProgress);

                var cards = shouldPreserveCards
                ? existingCards.Select(c => c with { IsWild = IsWildCard(c.Rank, c.Suit) }).ToList()
                : publicSeat.Cards.Select(c => new CardInfo
                {
                    Rank = c.IsFaceUp ? c.Rank : null,
                    Suit = c.IsFaceUp ? c.Suit : null,
                    IsFaceUp = c.IsFaceUp,
                    IsPubliclyVisible = c.IsFaceUp,
                    IsSelected = false,
                    DealOrder = c.DealOrder,
                    IsWild = c.IsFaceUp && IsWildCard(c.Rank, c.Suit)
                }).ToList();

                // Preserve LastActionDescription if it hasn't expired (5 seconds)
                var existingSeat = _seats[publicSeat.SeatIndex];

                // For Kings and Lows, show "Dropped" status for folded players throughout the hand
                string? lastActionDescription = null;
                DateTimeOffset? lastActionTime = null;

                if (IsKingsAndLows && publicSeat.IsFolded)
                {
                    lastActionDescription = "Dropped";
                    lastActionTime = existingSeat.LastActionTime ?? DateTimeOffset.UtcNow;
                }
                else if (IsKingsAndLows && _isPausedForChipCheck && IsPlayerShortOnChips(publicSeat.SeatIndex, publicSeat.Chips))
                {
                    // Show "Waiting for chips" status for players who are short during chip check pause
                    lastActionDescription = "Waiting for chips";
                    lastActionTime = DateTimeOffset.UtcNow;
                }
                else
                {
                    // For other games, preserve the action description for 5 seconds
                    var shouldPreserveAction = !string.IsNullOrWhiteSpace(existingSeat.LastActionDescription) &&
                    existingSeat.LastActionTime.HasValue &&
                    (DateTimeOffset.UtcNow - existingSeat.LastActionTime.Value).TotalSeconds < 5;

                    lastActionDescription = shouldPreserveAction ? existingSeat.LastActionDescription : null;
                    lastActionTime = shouldPreserveAction ? existingSeat.LastActionTime : null;
                }

                _seats[publicSeat.SeatIndex] = new SeatInfo
                {
                    SeatIndex = publicSeat.SeatIndex,
                    IsOccupied = publicSeat.IsOccupied,
                    PlayerName = publicSeat.PlayerName,
                    PlayerAvatarUrl = publicSeat.PlayerAvatarUrl,
                    PlayerFirstName = publicSeat.PlayerFirstName,
                    Chips = publicSeat.Chips,
                    IsReady = publicSeat.IsReady,
                    IsCurrentPlayer = isCurrentPlayer,
                    IsFolded = publicSeat.IsFolded,
                    IsAllIn = publicSeat.IsAllIn,
                    IsDisconnected = publicSeat.IsDisconnected,
                    IsSittingOut = publicSeat.IsSittingOut,
                    SittingOutReason = publicSeat.SittingOutReason,
                    CurrentBet = publicSeat.CurrentBet,
                    HasDecidedDropOrStay = publicSeat.HasDecidedDropOrStay,
                    Cards = cards,
                    LastActionDescription = lastActionDescription,
                    LastActionTime = lastActionTime
                };
            }
        }

        // Clear seats that were occupied but are missing from the update (player left)
        for (var i = 0; i < _seats.Count; i++)
        {
            if (_seats[i].IsOccupied && !updatedSeatIndices.Contains(i))
            {
                _seats[i] = new SeatInfo { SeatIndex = i };
            }
        }
    }

    private void UpdateShowdownFromPublicState(ShowdownPublicDto showdown, bool delayShowingOverlay = false)
    {
        // Build showdown result from public state ONLY when showdown.IsComplete is true.
        // This means the server has already performed the showdown (PerformShowdown API was called),
        // set NextHandStartsAt, and transitioned to Complete phase.
        //
        // CRITICAL: Do NOT populate _showdownResult when IsShowdownPhase is true but IsComplete is false!
        // If we do, TryLoadShowdownAsync will see _showdownResult is not null and skip calling the
        // PerformShowdown API. This would leave NextHandStartsAt unset and the next hand would never start.
        //
        // For Kings and Lows and PotMatching phase, we also allow processing as those have special flows.
        // IMPORTANT: If we're delaying the overlay (e.g., for animation), don't set _showdownResult
        // so that TryLoadShowdownAsync can fetch complete data from the API later
        // Also skip if we're in the middle of processing a deck draw - we want the API data instead
        if (delayShowingOverlay || _isProcessingDeckDraw)
        {
            return;
        }

        // Only process showdown from SignalR when:
        // 1. We don't already have a result
        // 2. AND (the showdown is complete (PerformShowdown was called) OR we're in PotMatching phase for Kings and Lows)
        // Do NOT process when IsShowdownPhase is true but IsComplete is false - let TryLoadShowdownAsync call the API
        var shouldProcessShowdown = _showdownResult is null &&
        (showdown.IsComplete || IsPotMatchingPhase);

        if (shouldProcessShowdown)
        {
            var payouts = showdown.PlayerResults
            .Where(r => r.IsWinner)
            .ToDictionary(r => r.PlayerName, r => r.AmountWon);

            var highHandPayouts = showdown.PlayerResults
            .Where(r => r.IsHighHandWinner && r.HighHandAmountWon > 0)
            .ToDictionary(r => r.PlayerName, r => r.HighHandAmountWon);

            var highHandWinners = showdown.PlayerResults
            .Where(r => r.IsHighHandWinner && r.HighHandAmountWon > 0)
            .Select(r => r.PlayerName)
            .ToList();

            var sevensPayouts = showdown.PlayerResults
            .Where(r => r.IsSevensWinner && r.SevensAmountWon > 0)
            .ToDictionary(r => r.PlayerName, r => r.SevensAmountWon);

            var sevensWinners = showdown.PlayerResults
            .Where(r => r.IsSevensWinner && r.SevensAmountWon > 0)
            .Select(r => r.PlayerName)
            .ToList();

            var playerHands = showdown.PlayerResults
            .Select(r => new ShowdownPlayerHand(
            amountWon: r.AmountWon,
            cards: ConvertCardsToShowdownCards(r.Cards),
            handDescription: r.HandDescription ?? "",
            handStrength: null,
            handType: r.HandRanking ?? "",
            highHandAmountWon: r.HighHandAmountWon,
            isHighHandWinner: r.IsHighHandWinner,
            isSevensWinner: r.IsSevensWinner,
            isWinner: r.IsWinner,
            playerFirstName: r.PlayerFirstName,
            playerName: r.PlayerName,
            sevensAmountWon: r.SevensAmountWon,
            wildCardIndexes: r.WildCardIndexes?.ToList() ?? [])
            {
                BestCardIndexes = r.BestCardIndexes?.ToList()
            })
            .ToList();

            _showdownResult = new PerformShowdownSuccessful(
            currentPhase: "Complete",
            gameId: GameId,
            payouts: payouts,
            highHandWinners: highHandWinners,
            sevensPoolRolledOver: showdown.SevensPoolRolledOver,
            highHandPayouts: highHandPayouts,
            playerHands: playerHands,
            sevensPayouts: sevensPayouts,
            wonByFold: false,
            sevensWinners: sevensWinners);

            // Only show overlay immediately if we're not delaying
            if (!delayShowingOverlay)
            {
                _showShowdownOverlay = true;

                // Initialize countdown timer when showdown is loaded from SignalR
                // This ensures the timer starts even if TryLoadShowdownAsync is never called
                // or returns early because result is already loaded
                if (_secondsUntilNextHand <= 0)
                {
                    _secondsUntilNextHand = ContinuousPlayResultsDisplayDurationSeconds;
                }
                _isResultsPhase = true;
                StartCountdownTimer();
            }

            _showdownWon = _showdownResult.Payouts?.Keys.Any(p =>
            string.Equals(p, _loggedInUserEmail, StringComparison.OrdinalIgnoreCase) ||
            string.Equals(p, _currentPlayerName, StringComparison.OrdinalIgnoreCase)) == true
            || highHandWinners.Any(p =>
            string.Equals(p, _loggedInUserEmail, StringComparison.OrdinalIgnoreCase) ||
            string.Equals(p, _currentPlayerName, StringComparison.OrdinalIgnoreCase));

            _showdownLost = !_showdownWon;
        }
    }

    private static ICollection<ShowdownCard> ConvertCardsToShowdownCards(IReadOnlyList<CardPublicDto>? cards)
    {
        if (cards is null || cards.Count == 0)
        {
            return [];
        }

        return cards
        .Where(c => c.IsFaceUp && !string.IsNullOrWhiteSpace(c.Rank) && !string.IsNullOrWhiteSpace(c.Suit))
        .Select(c => new ShowdownCard(
        suit: ParseCardSuit(c.Suit),
        symbol: ParseCardSymbol(c.Rank)
        ))
        .ToList();
    }

    private static CardSuit? ParseCardSuit(string? suit)
    {
        if (string.IsNullOrWhiteSpace(suit))
        {
            return null;
        }

        return suit.Trim().ToLowerInvariant() switch
        {
            "hearts" or "h" => CardSuit.Hearts,
            "diamonds" or "d" => CardSuit.Diamonds,
            "spades" or "s" => CardSuit.Spades,
            "clubs" or "c" => CardSuit.Clubs,
            _ => null
        };
    }

    private static CardSymbol? ParseCardSymbol(string? rank)
    {
        if (string.IsNullOrWhiteSpace(rank))
        {
            return null;
        }

        return rank.Trim().ToUpperInvariant() switch
        {
            "2" or "TWO" or "DEUCE" => CardSymbol.Deuce,
            "3" or "THREE" => CardSymbol.Three,
            "4" or "FOUR" => CardSymbol.Four,
            "5" or "FIVE" => CardSymbol.Five,
            "6" or "SIX" => CardSymbol.Six,
            "7" or "SEVEN" => CardSymbol.Seven,
            "8" or "EIGHT" => CardSymbol.Eight,
            "9" or "NINE" => CardSymbol.Nine,
            "10" or "T" or "TEN" => CardSymbol.Ten,
            "J" or "JACK" => CardSymbol.Jack,
            "Q" or "QUEEN" => CardSymbol.Queen,
            "K" or "KING" => CardSymbol.King,
            "A" or "ACE" => CardSymbol.Ace,
            _ => null
        };
    }

    private static List<BettingActionType> MapLegalActionsFromPrivateState(AvailableActionsDto available)
    {
        var actions = new List<BettingActionType>();

        if (available.CanFold) actions.Add(BettingActionType.Fold);
        if (available.CanCheck) actions.Add(BettingActionType.Check);
        if (available.CanCall) actions.Add(BettingActionType.Call);
        if (available.CanBet) actions.Add(BettingActionType.Bet);
        if (available.CanRaise) actions.Add(BettingActionType.Raise);
        if (available.CanAllIn) actions.Add(BettingActionType.AllIn);

        return actions;
    }

    private async Task<string?> GetLoggedInUserEmailAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity?.IsAuthenticated != true)
        {
            return null;
        }

        // Common claim locations across providers.
        return user.FindFirstValue(ClaimTypes.Email)
        ?? user.FindFirstValue("email")
        ?? user.FindFirstValue("preferred_username")
        ?? user.Identity?.Name;
    }

    private void InitializeSeats()
    {
        _seats = Enumerable.Range(0, 8)
        .Select(i => new SeatInfo { SeatIndex = i })
        .ToList();
    }

    private GetGameResponse? _gameResponse;
    private async Task LoadDataAsync()
    {
        try
        {
            _loggedInUserEmail ??= await GetLoggedInUserEmailAsync();

            // Use the generic Games API to load game data - it returns the game type code
            var gameResponse = await GamesApiClient.GetGameAsync(GameId);
            if (gameResponse is { IsSuccessStatusCode: true, Content: not null })
            {
                var gamesResponse = gameResponse.Content;
                _gameTypeCode = gamesResponse.GameTypeCode;

                // Convert to GetGameResponse format for compatibility with existing code
                _gameResponse = new GetGameResponse(
                ante: gamesResponse.Ante,
                bigBet: gamesResponse.BigBet,
                bigBlind: gamesResponse.BigBlind,
                bringIn: gamesResponse.BringIn,
                bringInPlayerIndex: gamesResponse.BringInPlayerIndex,
                canContinue: gamesResponse.CanContinue,
                createdAt: gamesResponse.CreatedAt,
                createdById: gamesResponse.CreatedById,
                createdByName: gamesResponse.CreatedByName,
                currentDrawPlayerIndex: gamesResponse.CurrentDrawPlayerIndex,
                currentHandNumber: gamesResponse.CurrentHandNumber,
                currentPhase: gamesResponse.CurrentPhase,
                currentPhaseDescription: gamesResponse.CurrentPhaseDescription,
                currentPlayerIndex: gamesResponse.CurrentPlayerIndex,
                dealerPosition: gamesResponse.DealerPosition,
                endedAt: gamesResponse.EndedAt,
                gameSettings: gamesResponse.GameSettings,
                gameTypeCode: gamesResponse.GameTypeCode,
                gameTypeId: gamesResponse.GameTypeId,
                gameTypeName: gamesResponse.GameTypeName,
                id: gamesResponse.Id,
                maximumNumberOfPlayers: gamesResponse.MaximumNumberOfPlayers,
                minBet: gamesResponse.MinBet,
                minimumNumberOfPlayers: gamesResponse.MinimumNumberOfPlayers,
                name: gamesResponse.Name,
                randomSeed: gamesResponse.RandomSeed,
                rowVersion: gamesResponse.RowVersion,
                smallBet: gamesResponse.SmallBet,
                smallBlind: gamesResponse.SmallBlind,
                startedAt: gamesResponse.StartedAt,
                status: gamesResponse.Status,
                updatedAt: gamesResponse.UpdatedAt
                );

                _currentActorSeatIndex = _gameResponse.CurrentPlayerIndex;
                _dealerSeatIndex = _gameResponse.DealerPosition;
            }

            await GetPlayersAndUpdateSeatsAsync();

            // Load game rules for dynamic UI rendering
            if (!string.IsNullOrWhiteSpace(_gameTypeCode))
            {
                _gameRules = await GameRulesService.GetGameRulesAsync(_gameTypeCode);
            }

            // Hand history is provided via SignalR in the initial state and updates

            if (IsShowdownPhase)
            {
                await TryLoadShowdownAsync();
            }

            // SignalR will handle state updates - no polling needed
            // Initial state snapshot is sent when joining the game via SignalR
        }
        finally
        {
            _seatedPlayerCount = _seats.Count(s => s.IsOccupied);
            var activePlayers = _seats.Where(s => s.IsOccupied && !s.IsSittingOut);
            _canStartGame = activePlayers.Count() >= (_gameResponse?.MinimumNumberOfPlayers ?? 2) &&
            activePlayers.All(s => s.IsReady);

            // Determine if current user is the host (game creator)
            _isHost = !string.IsNullOrWhiteSpace(_loggedInUserEmail) &&
            !string.IsNullOrWhiteSpace(_gameResponse?.CreatedByName) &&
            string.Equals(_loggedInUserEmail, _gameResponse.CreatedByName, StringComparison.OrdinalIgnoreCase);

            // Determine current player seat by matching logged-in email to seat PlayerName (case-insensitive).
            _currentPlayerName ??= _loggedInUserEmail;
            _currentPlayerSeatIndex = _seats.FirstOrDefault(s => s.IsOccupied &&
            !string.IsNullOrWhiteSpace(_currentPlayerName) &&
            string.Equals(s.PlayerName, _currentPlayerName, StringComparison.OrdinalIgnoreCase))?.SeatIndex ?? -1;

            _isSeated = _currentPlayerSeatIndex >= 0;
            _isReady = _isSeated && _seats[_currentPlayerSeatIndex].IsReady;
            _isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task GetPlayersAndUpdateSeatsAsync()
    {
        var playersResponse = await GamesApiClient.GetGamePlayersAsync(GameId);

        if (playersResponse is { IsSuccessStatusCode: true, Content: not null })
        {
            var players = playersResponse.Content.ToList();
            // Reset seats to ensure clean state
            InitializeSeats();

            foreach (var player in players)
            {
                if (player.SeatPosition < 0 || player.SeatPosition >= _seats.Count)
                {
                    continue;
                }

                var currentUserMatch = _currentPlayerName ?? _loggedInUserEmail;
                var isCurrentPlayer = !string.IsNullOrWhiteSpace(currentUserMatch) &&
                string.Equals(player.PlayerName, currentUserMatch, StringComparison.OrdinalIgnoreCase);

                // Capture the current player's ID for API calls
                if (isCurrentPlayer)
                {
                    _currentPlayerId = player.PlayerId;
                }

                _seats[player.SeatPosition] = new SeatInfo
                {
                    SeatIndex = player.SeatPosition,
                    IsOccupied = true,
                    PlayerName = player.PlayerName,
                    PlayerAvatarUrl = player.PlayerAvatarUrl,
                    PlayerFirstName = player.PlayerFirstName,
                    Chips = player.StartingChips,
                    IsReady = player.Status == GamePlayerStatus.Active,
                    IsCurrentPlayer = isCurrentPlayer,
                    IsFolded = player.HasFolded,
                    IsSittingOut = player.IsSittingOut,
                    SittingOutReason = player.IsSittingOut && player.HasFolded ? "Observing" : (player.IsSittingOut ? "Sitting out" : null),
                    Cards = player.Hand.OrderBy(c => c.DealOrder).Select(c => new CardInfo
                    {
                        Rank = c.Symbol.ToCardRankString(),
                        Suit = c.Suit.ToCardSuitString(),
                        IsFaceUp = isCurrentPlayer,
                        IsSelected = false,
                        IsWild = isCurrentPlayer && IsWildCard(c.Symbol.ToCardRankString(), c.Suit.ToCardSuitString())
                    }).ToList()
                };
            }

            _currentPlayerSeatIndex = _seats.FirstOrDefault(s => s.IsCurrentPlayer)?.SeatIndex ?? _currentPlayerSeatIndex;
        }
        else
        {
            // Handle error (e.g., show message)
        }
    }

    private bool _isLeavingTable = false;

    private async Task ToggleSitOutAsync()
    {
        try
        {
            var newState = !IsSittingOut;
            var response = await GamesApiClient.ToggleSitOutAsync(
            GameId,
            new ToggleSitOutRequest { IsSittingOut = newState });

            if (response.IsSuccessStatusCode && response.Content != null)
            {
                var result = response.Content;
                await ShowToastAsync(result.Message, "info");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to toggle sit out status");
            await ShowToastAsync("Failed to update status", "error");
        }
    }

    private async Task LeaveTableAsync()
    {
        if (_isLeavingTable)
            return; // Prevent double-clicks

        _isLeavingTable = true;

        try
        {
            // Call the new Leave Game API endpoint
            var response = await GamesApiClient.LeaveGameAsync(GameId);

            if (response.IsSuccessStatusCode && response.Content != null)
            {
                var result = response.Content;

                if (!result.Immediate)
                {
                    // Player is in active hand - show toast message
                    _hasRequestedLeave = true;
                    await ShowToastAsync(
                    result.Message ?? "You will leave after the current hand completes.",
                    "info",
                    durationMs: 6000);

                    // Stay on page until hand completes
                    // Background service will handle actual removal
                    return;
                }

                // Immediate leave - disconnect from SignalR and navigate to lobby
                await GameHubClient.LeaveGameAsync(GameId);
                NavigationManager.NavigateTo("/lobby");
            }
            else
            {
                // Show error toast
                var errorMessage = response.Error?.Content ?? "Failed to leave the table.";
                await ShowToastAsync(errorMessage, "error");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error leaving table {GameId}", GameId);
            await ShowToastAsync("An error occurred while leaving the table.", "error");
        }
        finally
        {
            _isLeavingTable = false;
        }
    }

    private async Task HandleSeatClickAsync(int seatIndex)
    {
        if (_isSeated || _seats[seatIndex].IsOccupied)
            return;

        try
        {
            // Call the API to join the game at this seat
            var request = new Api.Clients.JoinGameRequest(seatIndex, 100);//TODO:ROB - Set this to 50, or better yet, prompt them first

            var response = await GamesApiClient.JoinGameAsync(GameId, request);

            if (!response.IsSuccessStatusCode)
            {
                Logger.LogWarning("Failed to join game at seat {SeatIndex}: {StatusCode} - {Error}",
                seatIndex, response.StatusCode, response.Error?.Content);
                return;
            }

            // Update local state - SignalR will also broadcast the update
            _loggedInUserEmail ??= await GetLoggedInUserEmailAsync();
            var canPlay = response.Content?.CanPlayCurrentHand ?? false;

            // Store the player ID for API calls (e.g., Drop or Stay decision)
            _currentPlayerId = response.Content?.PlayerId;

            _seats[seatIndex] = new SeatInfo
            {
                SeatIndex = seatIndex,
                IsOccupied = true,
                PlayerName = response.Content?.PlayerName ?? _loggedInUserEmail ?? "You",
                PlayerAvatarUrl = response.Content?.PlayerAvatarUrl,
                PlayerFirstName = response.Content?.PlayerFirstName,
                Chips = 100, //TODO:ROB - Set this to 50, or better yet, prompt them first
                IsCurrentPlayer = true,
                IsReady = false,
                IsFolded = !canPlay,
                SittingOutReason = !canPlay ? "Observing" : null
            };
            _isSeated = true;
            _currentPlayerSeatIndex = seatIndex;

            Logger.LogInformation(
            "Successfully joined game {GameId} at seat {SeatIndex}. CanPlayCurrentHand: {CanPlay}",
            GameId, seatIndex, response.Content?.CanPlayCurrentHand);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error joining game at seat {SeatIndex}", seatIndex);
        }
    }

    private async Task SetReadyAsync()
    {
        if (IsSittingOut)
        {
            await ToggleSitOutAsync();
        }

        // TODO: Send ready request to server
        _isReady = true;
        if (_currentPlayerSeatIndex >= 0)
        {
            _seats[_currentPlayerSeatIndex].IsReady = true;
        }
        await Task.CompletedTask;
    }

    private async Task StartGameAsync()
    {
        if (!_isHost || !_canStartGame)
        {
            return;
        }

        _isSubmittingAction = false;
        _isPlayerTurn = false;

        if (IsTwosJacksManWithTheAxe)
        {
            var startHandResponse = await TwosJacksManWithTheAxeApi.TwosJacksManWithTheAxeStartHandAsync(GameId);
            if (!startHandResponse.IsSuccessStatusCode)
            {
                return;
            }

            var collectAntesResponse = await TwosJacksManWithTheAxeApi.TwosJacksManWithTheAxeCollectAntesAsync(GameId);
            if (!collectAntesResponse.IsSuccessStatusCode)
            {
                return;
            }

            var dealHandsResponse = await TwosJacksManWithTheAxeApi.TwosJacksManWithTheAxeDealHandsAsync(GameId);
            if (!dealHandsResponse.IsSuccessStatusCode)
            {
                return;
            }
        }
        else if (IsSevenCardStud)
        {
            var startHandResponse = await SevenCardStudApi.SevenCardStudStartHandAsync(GameId);
            if (!startHandResponse.IsSuccessStatusCode)
            {
                return;
            }

            var collectAntesResponse = await SevenCardStudApi.SevenCardStudCollectAntesAsync(GameId);
            if (!collectAntesResponse.IsSuccessStatusCode)
            {
                return;
            }

            var dealHandsResponse = await SevenCardStudApi.SevenCardStudDealHandsAsync(GameId);
            if (!dealHandsResponse.IsSuccessStatusCode)
            {
                return;
            }
        }
        else if (IsBaseball)
        {
            var startHandResponse = await BaseballApi.BaseballStartHandAsync(GameId);
            if (!startHandResponse.IsSuccessStatusCode)
            {
                return;
            }

            var collectAntesResponse = await BaseballApi.BaseballCollectAntesAsync(GameId);
            if (!collectAntesResponse.IsSuccessStatusCode)
            {
                return;
            }

            var dealHandsResponse = await BaseballApi.BaseballDealHandsAsync(GameId);
            if (!dealHandsResponse.IsSuccessStatusCode)
            {
                return;
            }
        }
        else if (IsFollowTheQueen)
        {
            var startHandResponse = await FollowTheQueenApi.FollowTheQueenStartHandAsync(GameId);
            if (!startHandResponse.IsSuccessStatusCode)
            {
                return;
            }

            var collectAntesResponse = await FollowTheQueenApi.FollowTheQueenCollectAntesAsync(GameId);
            if (!collectAntesResponse.IsSuccessStatusCode)
            {
                return;
            }

            var dealHandsResponse = await FollowTheQueenApi.FollowTheQueenDealHandsAsync(GameId);
            if (!dealHandsResponse.IsSuccessStatusCode)
            {
                return;
            }
        }
        else if (IsKingsAndLows)
        {
            // Kings and Lows has a simpler flow - StartHand handles ante collection and dealing
            var startHandResponse = await KingsAndLowsApi.KingsAndLowsStartHandAsync(GameId);
            if (!startHandResponse.IsSuccessStatusCode)
            {
                return;
            }
        }
        else
        {
            var startHandResponse = await FiveCardDrawApiClient.FiveCardDrawStartHandAsync(GameId);
            if (!startHandResponse.IsSuccessStatusCode)
            {
                return;
            }

            var collectAntesResponse = await FiveCardDrawApiClient.FiveCardDrawCollectAntesAsync(GameId);
            if (!collectAntesResponse.IsSuccessStatusCode)
            {
                return;
            }

            var dealHandsResponse = await FiveCardDrawApiClient.FiveCardDrawDealHandsAsync(GameId);
            if (!dealHandsResponse.IsSuccessStatusCode)
            {
                return;
            }
        }

        // SignalR will broadcast the updated state - no need to refresh manually
        await TryLoadShowdownAsync();
    }

    // Polling methods removed - SignalR handles state updates

    private async Task TryLoadShowdownAsync()
    {
        Logger.LogDebug("TryLoadShowdownAsync called. CurrentPhase={Phase}, IsShowdownPhase={IsShowdown}",
        _gameResponse?.CurrentPhase, IsShowdownPhase);

        if (!IsShowdownPhase)
        {
            Logger.LogDebug("TryLoadShowdownAsync: Not in showdown phase, returning early");
            return;
        }

        // If showdown result is already loaded (e.g., from SignalR update), just show the overlay
        // and ensure the countdown timer is running
        if (_showdownResult is not null)
        {
            Logger.LogDebug("TryLoadShowdownAsync: Showdown result already loaded, showing overlay");
            _showShowdownOverlay = true;

            // Ensure countdown timer is initialized (may have been missed if SignalR populated the result)
            if (_secondsUntilNextHand <= 0)
            {
                _secondsUntilNextHand = ContinuousPlayResultsDisplayDurationSeconds;
            }
            _isResultsPhase = true;
            StartCountdownTimer();

            await InvokeAsync(StateHasChanged);
            return;
        }

        _loggedInUserEmail ??= await GetLoggedInUserEmailAsync();

        Refit.IApiResponse<PerformShowdownSuccessful>? showdownResponse;
        if (IsTwosJacksManWithTheAxe)
        {
            showdownResponse = await TwosJacksManWithTheAxeApi.TwosJacksManWithTheAxePerformShowdownAsync(GameId);
        }
        else if (IsSevenCardStud)
        {
            showdownResponse = await SevenCardStudApi.SevenCardStudPerformShowdownAsync(GameId);
        }
        else if (IsBaseball)
        {
            showdownResponse = await BaseballApi.BaseballPerformShowdownAsync(GameId);
        }
        else if (IsKingsAndLows)
        {
            showdownResponse = await KingsAndLowsApi.KingsAndLowsPerformShowdownAsync(GameId);
        }
        else
        {
            showdownResponse = await FiveCardDrawApiClient.FiveCardDrawPerformShowdownAsync(GameId);
        }

        Logger.LogDebug("TryLoadShowdownAsync: Showdown API response - IsSuccess={IsSuccess}, HasContent={HasContent}",
        showdownResponse?.IsSuccessStatusCode, showdownResponse?.Content is not null);

        if (showdownResponse is not { IsSuccessStatusCode: true, Content: not null })
        {
            Logger.LogWarning("TryLoadShowdownAsync: Showdown API failed or returned no content. StatusCode={StatusCode}, Error={Error}",
            showdownResponse?.StatusCode, showdownResponse?.Error?.Content);
            return;
        }

        _showdownResult = showdownResponse.Content;
        _showShowdownOverlay = true;
        Logger.LogDebug("TryLoadShowdownAsync: Set _showShowdownOverlay=true, _showdownResult loaded");

        // Initialize countdown timer immediately after successful showdown
        // The SignalR broadcast will also arrive with the updated state, but we start
        // the timer proactively to avoid race conditions where the UI shows the overlay
        // without a countdown.
        _isResultsPhase = true;
        _secondsUntilNextHand = ContinuousPlayResultsDisplayDurationSeconds;
        StartCountdownTimer();

        if (string.IsNullOrWhiteSpace(_loggedInUserEmail) && string.IsNullOrWhiteSpace(_currentPlayerName))
        {
            _showdownWon = false;
            _showdownLost = false;
            return;
        }

        // Check against both email and display name since payout keys may use either
        var iWon = _showdownResult.Payouts?.Keys.Any(p =>
        string.Equals(p, _loggedInUserEmail, StringComparison.OrdinalIgnoreCase) ||
        string.Equals(p, _currentPlayerName, StringComparison.OrdinalIgnoreCase)) == true;
        _showdownWon = iWon;
        _showdownLost = !iWon;

        await InvokeAsync(StateHasChanged);
    }

    private void CloseShowdownOverlay()
    {
        _showShowdownOverlay = false;
    }

    // Note: StartRunoutAnimation has been inlined into HandleTableStateUpdatedAsync
    // to ensure the animation flag is set BEFORE UpdateSeatsFromPublicState is called.

    /// <summary>
    /// Timer callback that deals the next card in the runout sequence.
    /// Cards are dealt one at a time to one player at a time with 2-second delays.
    /// Example: P1 gets card, 2s delay, P2 gets card, 2s delay, P3 gets card, 2s delay, P1 gets next card...
    /// </summary>
    private async void DealNextRunoutCard(object? state)
    {
        if (_allInRunoutState?.RunoutCardsBySeat is null)
        {
            CompleteRunoutAnimation();
            return;
        }

        // Get the list of seat indices with cards to deal (sorted for consistent order)
        var seatIndices = _allInRunoutState.RunoutCardsBySeat.Keys
        .Where(s => s >= 0 && s < _seats.Count && _seats[s].IsOccupied && !_seats[s].IsFolded)
        .OrderBy(s => s)
        .ToList();

        if (seatIndices.Count == 0)
        {
            CompleteRunoutAnimation();
            return;
        }

        // Calculate how many cards each player needs to receive
        var maxRunoutCards = _allInRunoutState.RunoutCardsBySeat.Values
        .Select(cards => cards.Count)
        .DefaultIfEmpty(0)
        .Max();

        // Check if we've completed all streets
        if (_runoutCurrentStreetIndex >= maxRunoutCards)
        {
            // All cards dealt - wait 2 seconds then show showdown
            _runoutDealTimer?.Change(Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
            _ = Task.Run(async () =>
            {
                await Task.Delay(TimeSpan.FromSeconds(2));
                CompleteRunoutAnimation();
                await InvokeAsync(StateHasChanged);
            });
            return;
        }

        // Get the current seat to deal to
        if (_runoutCurrentSeatIndex >= seatIndices.Count)
        {
            // Finished dealing to all players for this street, move to next street
            _runoutCurrentSeatIndex = 0;
            _runoutCurrentStreetIndex++;

            // Check again if we've completed all streets
            if (_runoutCurrentStreetIndex >= maxRunoutCards)
            {
                _runoutDealTimer?.Change(Timeout.InfiniteTimeSpan, Timeout.InfiniteTimeSpan);
                _ = Task.Run(async () =>
                {
                    await Task.Delay(TimeSpan.FromSeconds(2));
                    CompleteRunoutAnimation();
                    await InvokeAsync(StateHasChanged);
                });
                return;
            }
        }

        // Deal ONE card to ONE player
        var currentSeatIndex = seatIndices[_runoutCurrentSeatIndex];
        if (_allInRunoutState.RunoutCardsBySeat.TryGetValue(currentSeatIndex, out var runoutCards))
        {
            var currentVisible = _runoutVisibleCardCount.GetValueOrDefault(currentSeatIndex, 0);
            if (currentVisible < runoutCards.Count)
            {
                var runoutCard = runoutCards[currentVisible];

                // Start flying card animation for runout
                _flyingCard = new TableCanvas.FlyingCardInfo(
                    TargetSeatIndex: currentSeatIndex,
                    CardIndex: currentVisible,
                    Rank: runoutCard.Rank,
                    Suit: runoutCard.Suit,
                    IsFaceUp: true
                );

                await InvokeAsync(StateHasChanged);

                // Wait for the flying animation to complete
                await Task.Delay(550);

                // Clear the flying card
                _flyingCard = null;

                _runoutVisibleCardCount[currentSeatIndex] = currentVisible + 1;
                UpdateSeatWithRunoutCards(currentSeatIndex, currentVisible + 1);

                Logger.LogDebug("Runout: Dealt card {CardNum} to seat {SeatIndex} (street {Street})",
                currentVisible + 1, currentSeatIndex, _runoutCurrentStreetIndex + 1);
            }
        }

        // Move to next player
        _runoutCurrentSeatIndex++;

        await InvokeAsync(StateHasChanged);

        // Schedule the next card deal in 2 seconds
        _runoutDealTimer?.Change(TimeSpan.FromSeconds(2), Timeout.InfiniteTimeSpan);
    }

    /// <summary>
    /// Updates a seat's cards by appending the next visible runout card.
    /// The initial cards are preserved, and runout cards are added one by one.
    /// </summary>
    private void UpdateSeatWithRunoutCards(int seatIndex, int visibleRunoutCards)
    {
        if (seatIndex < 0 || seatIndex >= _seats.Count)
        {
            return;
        }

        if (_allInRunoutState?.RunoutCardsBySeat is null ||
        !_allInRunoutState.RunoutCardsBySeat.TryGetValue(seatIndex, out var runoutCards))
        {
            return;
        }

        // Get the initial card count for this seat (captured when runout started)
        var initialCardCount = _runoutInitialCardCounts.GetValueOrDefault(seatIndex, 0);

        var seat = _seats[seatIndex];
        var existingCards = seat.Cards.ToList();

        Logger.LogDebug("UpdateSeatWithRunoutCards: Seat {SeatIndex}, initialCardCount={InitialCount}, existingCards={ExistingCount}, visibleRunoutCards={VisibleRunout}, totalRunoutCards={TotalRunout}",
        seatIndex, initialCardCount, existingCards.Count, visibleRunoutCards, runoutCards.Count);

        // Build the new cards list: initial cards + visible runout cards
        var allCards = new List<CardInfo>();

        // First, add the initial cards (cards dealt before runout)
        // These should already be in existingCards if we're preserving correctly
        for (var i = 0; i < Math.Min(initialCardCount, existingCards.Count); i++)
        {
            allCards.Add(existingCards[i]);
        }

        // Then add only the VISIBLE runout cards (face up)
        for (var i = 0; i < visibleRunoutCards && i < runoutCards.Count; i++)
        {
            var runoutCard = runoutCards[i];
            allCards.Add(new CardInfo
            {
                Rank = runoutCard.Rank,
                Suit = runoutCard.Suit,
                IsFaceUp = true,
                IsSelected = false,
                DealOrder = initialCardCount + i,
                IsWild = IsWildCard(runoutCard.Rank, runoutCard.Suit)
            });
        }

        _seats[seatIndex].Cards = allCards;

        Logger.LogDebug("UpdateSeatWithRunoutCards: Seat {SeatIndex} now has {CardCount} cards",
        seatIndex, allCards.Count);
    }

    private void StartCardDealAnimation(TableStatePublicDto state, int startCardIndex, int numberOfCardsToDeal)
    {
        Logger.LogInformation("Starting card deal animation for game {GameId}. StartIdx={Start}, Count={Count}", 
            GameId, startCardIndex, numberOfCardsToDeal);

        _dealAnimationInProgress = true;
        _dealTargetState = state;
        _dealCurrentCardIndex = startCardIndex; // Start dealing at this card index (e.g., 0 for initial, 3 for 4th street)
        _dealTargetEndIndex = startCardIndex + numberOfCardsToDeal; // Stop when index reaches this value
        _dealCurrentSeatIdx = 0;

        // Determine deal order: Start from Dealer + 1
        // Filter to seats that are occupied, not sitting out, AND NOT Folded in the NEW state
        // (Folded players do not receive new cards in Stud, except initially everyone is not folded)
        var activePublicSeats = state.Seats
            .Where(s => s.IsOccupied && !s.IsSittingOut && !s.IsFolded)
            .ToList();

        if (activePublicSeats.Count == 0)
        {
            CompleteCardDealAnimation();
            return;
        }

        // Create ordered list starting after dealer
        var dealerPos = state.DealerSeatIndex;
        _dealOrderedSeatIndices = activePublicSeats
            .Select(s => s.SeatIndex)
            .OrderBy(idx => (idx - dealerPos - 1 + 8) % 8) // Circular order after dealer
            .ToList();

        // Cache target cards from the NEW state to know rank/suit/faceup status
        _dealTargetCards.Clear();
        foreach (var seat in activePublicSeats)
        {
            _dealTargetCards[seat.SeatIndex] = seat.Cards
                .Select(c => new CardInfo { Rank = c.Rank, Suit = c.Suit, IsFaceUp = c.IsFaceUp })
                .ToList();
        }

        // Start Timer - 2000ms delay between cards per player
        _dealTimer = new Timer(DealNextCard, null, 100, 2000);
    }

    private async void DealNextCard(object? state)
    {
        if (!_dealAnimationInProgress) return;

        // Clear any previous flying card
        _flyingCard = null;

        // If we've completed all players for the current card index
        if (_dealCurrentSeatIdx >= _dealOrderedSeatIndices.Count)
        {
            // Move to next card in the sequence (e.g. from 1st card to 2nd card)
            _dealCurrentCardIndex++;
            _dealCurrentSeatIdx = 0;
        }

        // Check if we are done dealing all assigned cards
        if (_dealCurrentCardIndex >= _dealTargetEndIndex)
        {
            await InvokeAsync(() =>
            {
                _flyingCard = null;
                CompleteCardDealAnimation();
                StateHasChanged();
            });
            return;
        }

        // Deal card to current seat
        var seatIndex = _dealOrderedSeatIndices[_dealCurrentSeatIdx];

        // Find the seat in the current display state
        var seatListIndex = _seats.FindIndex(s => s.SeatIndex == seatIndex);

        if (seatListIndex >= 0)
        {
            var seat = _seats[seatListIndex];

            // Determine properties from the TARGET state
            string? rank = null;
            string? suit = null;
            bool isFaceUp = false;

            if (_dealTargetCards.TryGetValue(seatIndex, out var targetCards) && 
                _dealCurrentCardIndex < targetCards.Count)
            {
                var targetCard = targetCards[_dealCurrentCardIndex];
                rank = targetCard.Rank;
                suit = targetCard.Suit;
                isFaceUp = targetCard.IsFaceUp;
            }

            // Start flying card animation
            _flyingCard = new TableCanvas.FlyingCardInfo(
                TargetSeatIndex: seatIndex,
                CardIndex: _dealCurrentCardIndex,
                Rank: rank,
                Suit: suit,
                IsFaceUp: isFaceUp
            );

            await InvokeAsync(StateHasChanged);

            // Wait for the flying animation to complete (600ms matches CSS animation duration)
            await Task.Delay(550);

            // Clear the flying card and add card to the seat
            _flyingCard = null;

            // Create the card
            var newCard = new CardInfo
            {
                Rank = rank,
                Suit = suit,
                IsFaceUp = isFaceUp,
                IsSelected = false,
                DealOrder = _dealCurrentCardIndex,
                IsWild = IsWildCard(rank, suit)
            };

            // Safely add card. Check if we are replacing or adding.
            // Normally adding. But safeguard if list is somehow already large?
            // Since we preserved existingCards, usually we just append.
            var newHand = seat.Cards.ToList();
            if (newHand.Count > _dealCurrentCardIndex)
            {
                // This shouldn't happen if logic is correct, but if it does, update existing
                newHand[_dealCurrentCardIndex] = newCard;
            }
            else
            {
                newHand.Add(newCard);
            }

            _seats[seatListIndex] = seat with { Cards = newHand };

            Logger.LogDebug("Deal Animation: CardIdx {CardIdx}, Seat {SeatIndex}, FaceUp={FaceUp}",
                _dealCurrentCardIndex, seatIndex, isFaceUp);
        }

        _dealCurrentSeatIdx++;

        await InvokeAsync(StateHasChanged);
    }

    private void CompleteCardDealAnimation()
    {
        Logger.LogInformation("Card deal animation complete");

        _dealAnimationInProgress = false;
        _dealTimer?.Dispose();
        _dealTimer = null;
        _flyingCard = null;

        // Sync with Pending State
        if (_dealTargetState != null)
        {
            UpdateSeatsFromPublicState(_dealTargetState.Seats);
            _dealTargetState = null;
        }

        // Sync with Pending Private State (for current player hole cards)
        if (_dealPendingPrivateState != null)
        {
            _ = HandlePrivateStateUpdatedAsync(_dealPendingPrivateState);
            _dealPendingPrivateState = null;
        }
    }

    /// <summary>
    /// Completes the runout animation and triggers the showdown.
    /// </summary>
    private async void CompleteRunoutAnimation()
    {
        Logger.LogInformation("All-in runout animation complete, transitioning to showdown overlay");

        _runoutAnimationInProgress = false;
        _runoutDealTimer?.Dispose();
        _runoutDealTimer = null;
        _flyingCard = null;

        // Now load and show the showdown overlay
        await TryLoadShowdownAsync();

        await InvokeAsync(StateHasChanged);
    }

    private static List<BettingActionType> MapLegalActions(AvailableActionsResponse available)
    {
        var actions = new List<BettingActionType>();

        if (available.CanFold) actions.Add(BettingActionType.Fold);
        if (available.CanCheck) actions.Add(BettingActionType.Check);
        if (available.CanCall) actions.Add(BettingActionType.Call);
        if (available.CanBet) actions.Add(BettingActionType.Bet);
        if (available.CanRaise) actions.Add(BettingActionType.Raise);
        if (available.CanAllIn) actions.Add(BettingActionType.AllIn);

        return actions;
    }

    private async Task PauseGameAsync()
    {
        if (!_isHost)
        {
            return;
        }

        // TODO: Send pause request to server
        _isPaused = true;
        await Task.CompletedTask;
    }

    private async Task ResumeGameAsync()
    {
        if (!_isHost)
            return;

        // TODO: Send resume request to server
        _isPaused = false;
        await Task.CompletedTask;
    }

    private async Task EndGameAsync()
    {
        if (!_isHost)
            return;

        //TODO: Send end game request to server
        //_gameResponse.CurrentPhase = GamePhase.Ended;
        await Task.CompletedTask;
    }

    private async Task HandlePlayerActionAsync(PlayerActionRequest action)
    {
        if (!_isPlayerTurn || _isSubmittingAction)
            return;

        _isSubmittingAction = true;

        try
        {
            var request = new ProcessBettingActionRequest(action.Action, action.Amount ?? 0);
            var response = await GameApiRouter.ProcessBettingActionAsync(_gameTypeCode ?? "", GameId, request);

            if (!response.IsSuccess)
            {
                var errorMessage = response.Error ?? "An unknown error occurred.";
                await ShowToastAsync(errorMessage, "error");
                return;
            }

            // SignalR will broadcast the updated state - no need to refresh manually
        }
        finally
        {
            _isSubmittingAction = false;
        }
    }

    /// <summary>
    /// Extracts the error message from a Refit API exception.
    /// The API returns errors as JSON objects with a "message" property.
    /// </summary>
    private string ExtractErrorMessage(Refit.ApiException? exception)
    {
        if (exception is null)
        {
            return "An unknown error occurred.";
        }

        if (string.IsNullOrWhiteSpace(exception.Content))
        {
            return exception.Message ?? "An error occurred.";
        }

        try
        {
            // Parse the JSON response: {"message": "..."}
            using var doc = System.Text.Json.JsonDocument.Parse(exception.Content);
            if (doc.RootElement.TryGetProperty("message", out var messageElement))
            {
                return messageElement.GetString() ?? "An error occurred.";
            }
            // Fallback: try "Message" with capital M
            if (doc.RootElement.TryGetProperty("Message", out var messageElementUpper))
            {
                return messageElementUpper.GetString() ?? "An error occurred.";
            }
        }
        catch (System.Text.Json.JsonException)
        {
            // If JSON parsing fails, return the raw content
            return exception.Content;
        }

        return exception.Message ?? "An error occurred.";
    }

    private async Task HandleDrawActionAsync(List<int> discardIndices)
    {
        if (!_isPlayerDrawTurn || _isSubmittingDraw)
            return;

        _selectedDiscardIndices.Clear();
        foreach (var i in discardIndices)
        {
            _selectedDiscardIndices.Add(i);
        }

        _isSubmittingDraw = true;
        _isDrawAnimating = true;
        _forceShowDrawPanel = true;
        _delayShowdownOverlay = true; // Delay showdown until animation completes
        _cardsDrawn = false;
        _newHandDescription = null;

        // Initialize draw cards for animation
        _currentPlayerDrawCards = _currentPlayerDrawCards.Select(c => c with { IsSelected = false }).ToList();
        foreach (var index in discardIndices)
        {
            if (index >= 0 && index < _currentPlayerDrawCards.Count)
            {
                _currentPlayerDrawCards[index] = _currentPlayerDrawCards[index] with { IsSelected = true };
            }
        }

        StateHasChanged();

        try
        {
            // Start discard animation
            if (discardIndices.Count > 0)
            {
                _isDiscardingCards = true;

                // Mark selected cards visually for animation
                for (int i = 0; i < _currentPlayerDrawCards.Count; i++)
                {
                    if (discardIndices.Contains(i))
                    {
                        _currentPlayerDrawCards[i] = _currentPlayerDrawCards[i] with { IsSelected = true };
                    }
                }
                await InvokeAsync(StateHasChanged);

                // Wait for discard animation
                await Task.Delay(600);
            }

            // Make the API call
            var playerId = _currentPlayerId ?? Guid.Empty;
            var response = await GameApiRouter.ProcessDrawAsync(_gameTypeCode ?? "", GameId, playerId, discardIndices);

            if (!response.IsSuccess || response.Content is null)
            {
                // Reset state on failure
                _isDiscardingCards = false;
                _isDrawAnimating = false;
                _isSubmittingDraw = false;
                Logger.LogWarning("Draw action failed: {Error}", response.Error);
                return;
            }

            var result = response.Content.Original;
            if (!string.IsNullOrEmpty(response.Content.NewHandDescription))
            {
                _newHandDescription = response.Content.NewHandDescription;
            }

            // Transition to drawing new cards animation
            _isDiscardingCards = false;

            // Handle stand pat (0 discards) case
            if (discardIndices.Count == 0)
            {
                // No cards to animate - just mark as complete
                _cardsDrawn = true;
                await InvokeAsync(StateHasChanged);

                // If draw phase is complete (we're now in DrawComplete phase), keep cards visible
                if (result?.DrawComplete == true)
                {
                    _isDrawAnimating = false;
                    _forceShowDrawPanel = false;
                    _delayShowdownOverlay = false;
                    // Cards stay in currentPlayerDrawCards for DrawComplete phase display
                    await InvokeAsync(StateHasChanged);

                    // Wait for the background service to transition to Showdown/Complete phase
                    // The background service has a 5-second delay, so we may need to wait
                    for (int i = 0; i < 10; i++)
                    {
                        if (IsShowdownPhase)
                        {
                            break;
                        }
                        await Task.Delay(500);
                    }

                    // Now try to load/show showdown
                    await TryLoadShowdownAsync();
                    return;
                }

                // Not the last player - no delay for stand pat
                // await Task.Delay(500);
                _isDrawAnimating = false;
                _currentPlayerDrawCards = [];
                _selectedDiscardIndices.Clear();
                _forceShowDrawPanel = false;
                _cardsDrawn = false;
                _newHandDescription = null;
                await InvokeAsync(StateHasChanged);
                return;
            }

            // Handle discards (1+ cards) case
            if (discardIndices.Count > 0)
            {
                // Swap in the newly dealt cards before the draw-in animation starts
                // so the cards that animate back in display the new values.
                if (result is not null)
                {
                    var newCards = result.NewCards?.ToList() ?? [];

                    for (var i = 0; i < discardIndices.Count && i < newCards.Count; i++)
                    {
                        var targetIndex = discardIndices[i];
                        if (targetIndex < 0 || targetIndex >= _currentPlayerDrawCards.Count)
                        {
                            continue;
                        }

                        var newCard = newCards[i];

                        _currentPlayerDrawCards[targetIndex] = new CardInfo
                        {
                            Rank = newCard.Symbol?.ToCardRankString(),
                            Suit = newCard.Suit?.ToCardSuitString(),
                            IsFaceUp = true,
                            IsSelected = false
                        };
                    }

                    await InvokeAsync(StateHasChanged);
                }

                _isDrawingNewCards = true;
                _newCardIndices = discardIndices;
                await InvokeAsync(StateHasChanged);

                // Wait for the draw-in animation to complete, then switch the status out of "Drawing...".
                await Task.Delay(700);
                _cardsDrawn = true;
                await InvokeAsync(StateHasChanged);

                // Keep the panel visible for 5 seconds so the player can see their new cards
                await Task.Delay(5000);

                _isDrawingNewCards = false;
                _newCardIndices = [];
            }

            // If draw phase is complete (we're now in DrawComplete phase), keep the cards visible
            // and let SignalR updates handle the transition to showdown
            if (result?.DrawComplete == true)
            {
                // Don't clear the cards - they'll be displayed during DrawComplete phase
                _isDrawAnimating = false;
                _forceShowDrawPanel = false;
                _cardsDrawn = false;
                _delayShowdownOverlay = false;
                // Cards stay in currentPlayerDrawCards for DrawComplete phase display
                await InvokeAsync(StateHasChanged);

                // Wait for the background service to transition to Showdown/Complete phase
                // The background service has a 5-second delay matching our animation delay,
                // so we may need to wait a bit longer for the phase transition
                for (int i = 0; i < 10; i++)
                {
                    if (IsShowdownPhase)
                    {
                        break;
                    }
                    await Task.Delay(500);
                }

                // Now try to load/show showdown
                await TryLoadShowdownAsync();
                return;
            }

            // Clear animation state (for non-last players)
            _isDrawAnimating = false;
            _currentPlayerDrawCards = [];
            _selectedDiscardIndices.Clear();
            _forceShowDrawPanel = false;
            _cardsDrawn = false;
            _newHandDescription = null;

            // Now show the showdown overlay after animation is complete
            _delayShowdownOverlay = false;
            await TryLoadShowdownAsync();

            // SignalR will broadcast the updated state - no need to refresh manually
        }
        finally
        {
            _isSubmittingDraw = false;
            _isDiscardingCards = false;
            _isDrawingNewCards = false;
            _isDrawAnimating = false;
            _delayShowdownOverlay = false; // Clear delay on completion or error

            // Only clear draw panel state if we're not in DrawComplete phase
            // During DrawComplete, we want the cards to remain visible
            if (!IsDrawCompletePhase)
            {
                _forceShowDrawPanel = false;
                _cardsDrawn = false;
                _newHandDescription = null;
            }
        }
    }

    private Task ToggleDiscardSelectionAsync(int index)
    {
        if (index < 0 || index >= _currentPlayerDrawCards.Count)
        {
            return Task.CompletedTask;
        }

        if (!_selectedDiscardIndices.Add(index))
        {
            _selectedDiscardIndices.Remove(index);
        }

        _currentPlayerDrawCards[index] = _currentPlayerDrawCards[index] with
        {
            IsSelected = _selectedDiscardIndices.Contains(index)
        };

        // Recalculate odds based on cards being kept (not selected for discard)
        RecalculateDrawOddsForSelection();

        return InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Recalculates the hand odds based on the current discard selection.
    /// Cards not selected for discard are kept, and the odds are calculated
    /// by simulating drawing replacement cards for the discarded ones.
    /// </summary>
    private void RecalculateDrawOddsForSelection()
    {
        try
        {
            // Get the cards being kept (not selected for discard)
            var cardsToKeep = _currentPlayerDrawCards
            .Where((card, index) => !_selectedDiscardIndices.Contains(index))
            .Select(c => ConvertToCard(c.Rank ?? "", c.Suit ?? ""))
            .Where(c => c is not null)
            .Cast<Card>()
            .ToList();

            if (cardsToKeep.Count == 0)
            {
                handOdds = [];
                return;
            }

            // Get dead cards: cards selected for discard + folded players' visible cards
            var discardedCards = _currentPlayerDrawCards
            .Where((card, index) => _selectedDiscardIndices.Contains(index))
            .Select(c => ConvertToCard(c.Rank ?? "", c.Suit ?? ""))
            .Where(c => c is not null)
            .Cast<Card>()
            .ToList();

            var foldedPlayerCards = _seats
            .Where(s => s.IsFolded && s.Cards.Any())
            .SelectMany(s => s.Cards)
            .Where(c => c.IsFaceUp && c.Rank is not null && c.Suit is not null)
            .Select(c => ConvertToCard(c.Rank!, c.Suit!))
            .Where(c => c is not null)
            .Cast<Card>()
            .ToList();

            // Discarded cards are dead cards (they won't be redrawn)
            var deadCards = discardedCards.Concat(foldedPlayerCards).ToList();

            OddsCalculator.OddsResult? result;
            if (IsTwosJacksManWithTheAxe)
            {
                result = OddsCalculator.CalculateTwosJacksManWithTheAxeDrawOdds(cardsToKeep, deadCards);
            }
            else if (IsSevenCardStud)
            {
                result = OddsCalculator.CalculateStudOdds(cardsToKeep, deadCards);
            }
            else if (IsKingsAndLows)
            {
                result = OddsCalculator.CalculateKingsAndLowsDrawOdds(cardsToKeep, deadCards);
            }
            else
            {
                result = OddsCalculator.CalculateDrawOdds(cardsToKeep, deadCards);
            }

            handOdds = ConvertToHandTypeOddsDtos(result);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to recalculate hand odds for discard selection");
            handOdds = [];
        }
    }

    /// <summary>
    /// Gets the leaderboard players from the current seats.
    /// </summary>
    private IReadOnlyList<LeaderboardSection.LeaderboardPlayer> GetLeaderboardPlayers()
    {
        return _seats
        .Where(s => s.IsOccupied && s.PlayerName is not null)
        .Select(s => new LeaderboardSection.LeaderboardPlayer(
        PlayerId: s.SeatIndex.ToString(),
        PlayerName: s.PlayerName!,
        DisplayName: s.PlayerFirstName,
        Chips: s.Chips))
        .OrderByDescending(p => p.Chips)
        .ToList();
    }

    private static string GetInitials(string? name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return "?";

        var parts = name.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        return parts.Length switch
        {
            0 => "?",
            1 => parts[0][..1].ToUpperInvariant(),
            _ => $"{parts[0][0]}{parts[^1][0]}".ToUpperInvariant()
        };
    }

    // Enums and Models
    public enum GamePhase
    {
        [Description("Waiting for Players")] WaitingForPlayers,
        [Description("Betting Round")] Dealing,
        [Description("Pre-Draw")] PreDraw,
        [Description("Drawing")] Drawing,
        [Description("Post-Draw")] PostDraw,
        [Description("Showdown")] Showdown,
        [Description("Ended")] Ended,
        [Description("Waiting to Start")] WaitingToStart,
        [Description("Complete")] Complete,
        [Description("Second Betting Round")] SecondBettingRound,
        [Description("Draw Phase")] DrawPhase,
        [Description("First Betting Round")] FirstBettingRound,
        [Description("Collecting Antes")] CollectingAntes,
        [Description("Drop or Stay")] DropOrStay,
        [Description("Pot Matching")] PotMatching,
    }

    public record SeatInfo
    {
        public int SeatIndex { get; init; }
        public bool IsOccupied { get; set; }
        public string? PlayerName { get; set; }
        public string? PlayerFirstName { get; set; }
        public string? PlayerAvatarUrl { get; set; }
        public int Chips { get; set; }
        public bool IsReady { get; set; }
        public bool IsCurrentPlayer { get; set; }
        public bool IsFolded { get; set; }
        public bool IsAllIn { get; set; }
        public bool IsDisconnected { get; set; }
        public bool IsSittingOut { get; set; }
        public string? SittingOutReason { get; set; }
        public int CurrentBet { get; set; }
        public bool HasDecidedDropOrStay { get; set; }
        public List<CardInfo> Cards { get; set; } = [];
        public string? HandEvaluationDescription { get; set; }
        /// <summary>
        /// The last action performed by this player (e.g., "Checked", "Raised 50").
        /// Displayed temporarily in the seat pill.
        /// </summary>
        public string? LastActionDescription { get; set; }
        /// <summary>
        /// The UTC time when the last action was performed.
        /// Used to determine when to hide the action display.
        /// </summary>
        public DateTimeOffset? LastActionTime { get; set; }
    }

    public record CardInfo
    {
        public string? Rank { get; init; }
        public string? Suit { get; init; }
        public bool IsFaceUp { get; init; }
        public bool IsPubliclyVisible { get; init; }
        public bool IsSelected { get; init; }
        public int DealOrder { get; init; }
        public bool IsWild { get; init; }
    }

    public record PlayerActionRequest(BettingActionType Action, int? Amount);

    public record ToastMessage(string Message, string Type);

    private void StartCountdownTimer()
    {
        // Only start if not already running
        if (_countdownTimer is not null)
        {
            return;
        }

        _countdownTimer = new System.Threading.Timer(async _ =>
        {
            if (_secondsUntilNextHand > 0)
            {
                _secondsUntilNextHand--;
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                StopCountdownTimer();

                // If game is ended and timer reached 0, redirect to lobby
                if (IsEndedPhase)
                {
                    await GameHubClient.LeaveGameAsync(GameId);
                    NavigationManager.NavigateTo("/lobby");
                }
                else
                {
                    // Countdown complete - hide the showdown overlay
                    // If we're paused for chip check, the ChipCoveragePauseOverlay will show instead
                    _showShowdownOverlay = false;
                    await InvokeAsync(StateHasChanged);
                }
            }
        }, null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
    }

    private void StopCountdownTimer()
    {
        _countdownTimer?.Dispose();
        _countdownTimer = null;
    }

    public async ValueTask DisposeAsync()
    {
        // Stop countdown timer
        StopCountdownTimer();

        // Stop runout animation timer
        _runoutDealTimer?.Dispose();
        _runoutDealTimer = null;

        // Stop card deal animation timer
        _dealTimer?.Dispose();
        _dealTimer = null;

        // Stop flying card timer
        _flyingCardTimer?.Dispose();
        _flyingCardTimer = null;
        _flyingCard = null;

        // Unsubscribe from SignalR events
        GameHubClient.OnTableStateUpdated -= HandleTableStateUpdatedAsync;
        GameHubClient.OnPrivateStateUpdated -= HandlePrivateStateUpdatedAsync;
        GameHubClient.OnPlayerJoined -= HandlePlayerJoinedAsync;
        GameHubClient.OnConnectionStateChanged -= HandleConnectionStateChanged;
        GameHubClient.OnActionTimerUpdated -= HandleActionTimerUpdatedAsync;
        GameHubClient.OnPlayerActionPerformed -= HandlePlayerActionPerformedAsync;

        // Leave the game and disconnect
        if (_currentGameId.HasValue)
        {
            await GameHubClient.LeaveGameAsync(_currentGameId.Value);
        }
    }

    /// <summary>
    /// Handles action timer updates from SignalR.
    /// </summary>
    private async Task HandleActionTimerUpdatedAsync(ActionTimerStateDto timerState)
    {
        _actionTimerState = timerState;
        await InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Handles player action performed notifications from SignalR.
    /// Updates the seat's last action display and starts a timer to clear it.
    /// </summary>
    private async Task HandlePlayerActionPerformedAsync(PlayerActionPerformedDto notification)
    {
        if (notification.GameId != GameId)
        {
            return;
        }

        var seatIndex = notification.SeatIndex;
        if (seatIndex < 0 || seatIndex >= _seats.Count)
        {
            return;
        }

        Logger.LogDebug("Player action performed at seat {SeatIndex}: {Action}",
        seatIndex, notification.ActionDescription);

        // Update the seat with the action
        _seats[seatIndex].LastActionDescription = notification.ActionDescription;
        _seats[seatIndex].LastActionTime = notification.PerformedAtUtc;

        await InvokeAsync(StateHasChanged);

        // Schedule the action to be cleared after the display duration
        var displayDuration = notification.DisplayDurationSeconds > 0
        ? notification.DisplayDurationSeconds
        : 5;

        _ = Task.Run(async () =>
        {
            await Task.Delay(TimeSpan.FromSeconds(displayDuration));

            // Only clear if this is still the same action (hasn't been replaced)
            if (seatIndex >= 0 && seatIndex < _seats.Count &&
    _seats[seatIndex].LastActionTime == notification.PerformedAtUtc)
            {
                _seats[seatIndex].LastActionDescription = null;
                _seats[seatIndex].LastActionTime = null;
                await InvokeAsync(StateHasChanged);
            }
        });
    }

    private Guid? _currentGameId => GameId;

    /// <summary>
    /// Calculates the hand odds locally using the OddsCalculator.
    /// </summary>
    private void CalculateHandOdds(IReadOnlyList<CardPrivateDto> playerCards)
    {
        if (playerCards.Count == 0)
        {
            handOdds = [];
            return;
        }

        try
        {
            // Convert CardPrivateDto to Card
            var coreCards = playerCards
            .Select(c => ConvertToCard(c.Rank, c.Suit))
            .Where(c => c is not null)
            .Cast<Card>()
            .ToList();

            if (coreCards.Count == 0)
            {
                handOdds = [];
                return;
            }

            // Get dead cards from folded players' visible cards
            var deadCards = _seats
            .Where(s => s.IsFolded && s.Cards.Any())
            .SelectMany(s => s.Cards)
            .Where(c => c.IsFaceUp && c.Rank is not null && c.Suit is not null)
            .Select(c => ConvertToCard(c.Rank!, c.Suit!))
            .Where(c => c is not null)
            .Cast<Card>()
            .ToList();

            OddsCalculator.OddsResult? result;
            if (IsTwosJacksManWithTheAxe)
            {
                result = OddsCalculator.CalculateTwosJacksManWithTheAxeDrawOdds(coreCards, deadCards);
            }
            else if (IsSevenCardStud)
            {
                result = OddsCalculator.CalculateStudOdds(coreCards, deadCards);
            }
            else if (IsBaseball)
            {
                var holeCards = coreCards.Take(2).ToList();
                var boardCards = coreCards.Skip(2).ToList();
                var totalCards = Math.Max(7, coreCards.Count);
                result = OddsCalculator.CalculateBaseballOdds(holeCards, boardCards, totalCards, deadCards);
            }
            else if (IsKingsAndLows)
            {
                result = OddsCalculator.CalculateKingsAndLowsDrawOdds(coreCards, deadCards);
            }
            else
            {
                result = OddsCalculator.CalculateDrawOdds(coreCards, deadCards);
            }

            handOdds = ConvertToHandTypeOddsDtos(result);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to calculate hand odds");
            handOdds = [];
        }
    }

    private static Card? ConvertToCard(string rank, string suit)
    {
        var symbolValue = rank.ToUpperInvariant() switch
        {
            "A" => 14,
            "K" => 13,
            "Q" => 12,
            "J" => 11,
            "10" or "T" => 10,
            "9" => 9,
            "8" => 8,
            "7" => 7,
            "6" => 6,
            "5" => 5,
            "4" => 4,
            "3" => 3,
            "2" => 2,
            _ => 0
        };

        if (symbolValue == 0)
        {
            return null;
        }

        var suitValue = suit.ToLowerInvariant() switch
        {
            "hearts" => Suit.Hearts,
            "diamonds" => Suit.Diamonds,
            "spades" => Suit.Spades,
            "clubs" => Suit.Clubs,
            _ => (Suit?)null
        };

        if (suitValue is null)
        {
            return null;
        }

        return new Card(suitValue.Value, symbolValue);
    }

    private static List<HandTypeOddsDto> ConvertToHandTypeOddsDtos(OddsCalculator.OddsResult result)
    {
        // Order hand types from best to worst for display
        var orderedHandTypes = new[]
        {
HandType.FiveOfAKind,
HandType.StraightFlush,
HandType.Quads,
HandType.FullHouse,
HandType.Flush,
HandType.Straight,
HandType.Trips,
HandType.TwoPair,
HandType.OnePair,
HandType.HighCard
};

        return orderedHandTypes
        .Where(ht => result.HandTypeProbabilities.ContainsKey(ht))
        .Select(ht => new HandTypeOddsDto(
        HandType: ht.ToString(),
        DisplayName: GetHandTypeDisplayName(ht),
        Probability: result.HandTypeProbabilities[ht]
        ))
        .ToList();
    }

    private static string GetHandTypeDisplayName(HandType handType) => handType switch
    {
        HandType.HighCard => "High Card",
        HandType.OnePair => "One Pair",
        HandType.TwoPair => "Two Pair",
        HandType.Trips => "Three of a Kind",
        HandType.Straight => "Straight",
        HandType.Flush => "Flush",
        HandType.FullHouse => "Full House",
        HandType.Quads => "Four of a Kind",
        HandType.StraightFlush => "Straight Flush",
        HandType.FiveOfAKind => "Five of a Kind",
        _ => handType.ToString()
    };

    // ============== Dynamic UI Helper Methods ==============

    /// <summary>
    /// Gets the title for the decision panel based on current game phase.
    /// </summary>
    private string GetDecisionTitle()
    {
        if (HasDropOrStay)
        {
            return "Drop or Stay?";
        }
        return _tableState?.CurrentPhaseDescription ?? "Make a Decision";
    }

    /// <summary>
    /// Gets the subtitle for the decision panel.
    /// </summary>
    private string GetDecisionSubtitle()
    {
        if (HasDropOrStay)
        {
            return "Choose to stay in the hand or drop out";
        }
        return "";
    }

    /// <summary>
    /// Gets the description for special phases.
    /// </summary>
    private string GetSpecialPhaseDescription()
    {
        if (HasPotMatching)
        {
            return "Losers must match the pot amount.";
        }
        if (IsBuyCardOfferPhase)
        {
            return "Waiting for buy card decisions.";
        }
        return "Please wait for this phase to complete.";
    }

    private CardInfo? GetBuyCardTriggerCard()
    {
        if (_buyCardOffer?.TriggerCard is null)
        {
            return null;
        }

        return new CardInfo
        {
            Rank = _buyCardOffer.TriggerCard.Rank,
            Suit = _buyCardOffer.TriggerCard.Suit,
            IsFaceUp = true,
            IsSelected = false,
            DealOrder = _buyCardOffer.TriggerCard.DealOrder
        };
    }

    /// <summary>
    /// Handles decision actions (like Drop/Stay).
    /// </summary>
    private async Task HandleDecisionAsync(string decision)
    {
        if (_isSubmittingAction)
        {
            return;
        }

        _isSubmittingAction = true;
        try
        {
            // Route to the correct API based on game type
            if (IsKingsAndLows && IsDropOrStayPhase)
            {
                // Use the dedicated Kings and Lows DropOrStay endpoint
                var request = new DropOrStayRequest(
                decision: decision,
                playerId: _currentPlayerId ?? Guid.Empty
                );

                var response = await GameApiRouter.DropOrStayAsync(_gameTypeCode ?? "", GameId, request);

                if (response.IsSuccess)
                {
                    _hasDropOrStayDecided = true;
                    _dropOrStayDecision = decision;
                    Logger.LogDebug("Drop or stay decision recorded via HandleDecisionAsync: {Decision}", decision);
                }
                else
                {
                    Logger.LogWarning("Decision failed: {Error}", response.Error);
                }
            }
            else
            {
                // For other game types, map decision to betting action
                var actionType = decision.ToUpperInvariant() switch
                {
                    "DROP" => BettingActionType.Fold,
                    "STAY" => BettingActionType.Check,
                    _ => BettingActionType.Check
                };

                var request = new ProcessBettingActionRequest(actionType, 0);
                var response = await GameApiRouter.ProcessBettingActionAsync(_gameTypeCode ?? "", GameId, request);

                if (!response.IsSuccess)
                {
                    Logger.LogWarning("Decision failed: {Error}", response.Error);
                }
            }
            // SignalR will broadcast the updated state
        }
        finally
        {
            _isSubmittingAction = false;
        }
    }

    private async Task HandleBuyCardDecisionAsync(bool accept)
    {
        if (_isProcessingBuyCard)
        {
            return;
        }

        if (!_currentPlayerId.HasValue || _currentPlayerId == Guid.Empty)
        {
            await ShowToastAsync("Unable to process buy card decision: player ID not available.", "error");
            return;
        }

        _isProcessingBuyCard = true;
        try
        {
            var request = new ProcessBuyCardRequest(_currentPlayerId.Value, accept);
            var response = await GameApiRouter.ProcessBuyCardAsync(_gameTypeCode ?? "", GameId, request);

            if (!response.IsSuccess)
            {
                await ShowToastAsync(response.Error ?? "Failed to process buy card decision.", "error");
            }
        }
        finally
        {
            _isProcessingBuyCard = false;
        }
    }

    /// <summary>
    /// Gets the maximum number of discards based on game rules.
    /// </summary>
    private int GetMaxDiscards()
    {
        // Use drawing config from table state if available, but ensure we respect
        // the personalized limit (e.g., having an Ace allows 4 discards instead of 3)
        var publicMax = _tableState?.DrawingConfig?.MaxDiscards ?? 3;
        return Math.Max(publicMax, _maxDiscards);
    }

    /// <summary>
    /// Gets special drawing rules message for display.
    /// </summary>
    private string? GetDrawingSpecialRules()
    {
        return _tableState?.DrawingConfig?.SpecialRules;
    }

    /// <summary>
    /// Determines if a card is wild based on game rules.
    /// </summary>
    private bool IsWildCard(CardInfo card) => IsWildCard(card.Rank, card.Suit);

    private bool IsWildCard(string? rank, string? suit)
    {
        var wildRules = _tableState?.SpecialRules?.WildCardRules;
        if (wildRules is null)
        {
            return false;
        }

        // Check specific cards (e.g., "KD" for King of Diamonds)
        if (wildRules.SpecificCards is not null && rank is not null && suit is not null)
        {
            var cardCode = $"{rank}{GetSuitCode(suit)}";
            if (wildRules.SpecificCards.Any(c => c.Equals(cardCode, StringComparison.OrdinalIgnoreCase)))
            {
                return true;
            }
        }

        // Check wild ranks (e.g., all 2s, all Jacks)
        if (wildRules.WildRanks is not null && rank is not null)
        {
            if (wildRules.WildRanks.Any(r => r.Equals(rank, StringComparison.OrdinalIgnoreCase)))
            {
                return true;
            }
        }

        // Lowest card is wild is handled by server marking the card
        return false;
    }

    /// <summary>
    /// Gets the suit code for wild card comparison.
    /// </summary>
    private static string GetSuitCode(string? suit) => suit?.ToUpperInvariant() switch
    {
        "CLUBS" => "C",
        "DIAMONDS" => "D",
        "HEARTS" => "H",
        "SPADES" => "S",
        _ => ""
    };

    /// <summary>
    /// Gets the wild cards for display in the TableCanvas panel.
    /// Returns game-specific wild cards:
    /// - Baseball: 3s and 9s
    /// - Follow the Queen: Queens + dynamic wild rank
    /// - Kings and Lows: Kings + player's lowest card (personalized)
    /// - Twos Jacks Man with the Axe: 2s, Jacks, and King of Diamonds
    /// </summary>
    private IReadOnlyList<TableCanvas.WildCardDisplay> GetWildCardsForDisplay()
    {
        var wildRules = _tableState?.SpecialRules?.WildCardRules;
        if (wildRules is null)
        {
            return [];
        }

        var wildCards = new List<TableCanvas.WildCardDisplay>();

        // Add specific cards first (e.g., King of Diamonds for Twos Jacks)
        if (wildRules.SpecificCards is { Count: > 0 })
        {
            foreach (var cardCode in wildRules.SpecificCards)
            {
                if (cardCode.Length >= 2)
                {
                    var rank = cardCode[..^1]; // Everything except last char
                    var suitCode = cardCode[^1..]; // Last char
                    var suitName = suitCode.ToUpperInvariant() switch
                    {
                        "C" => "Clubs",
                        "D" => "Diamonds",
                        "H" => "Hearts",
                        "S" => "Spades",
                        _ => null
                    };

                    if (suitName is not null)
                    {
                        var displayRank = GetDisplayRankName(rank);
                        wildCards.Add(new TableCanvas.WildCardDisplay(
                            Rank: rank,
                            Suit: suitName,
                            Label: $"{displayRank} of {suitName}"
                        ));
                    }
                }
            }
        }

        // Add wild ranks (all cards of certain ranks)
        if (wildRules.WildRanks is { Count: > 0 })
        {
            foreach (var rank in wildRules.WildRanks)
            {
                var label = GetWildRankLabel(rank);
                wildCards.Add(new TableCanvas.WildCardDisplay(
                    Rank: rank,
                    Suit: null,
                    Label: label
                ));
            }
        }

        // Add personalized wild card for "lowest card is wild" (Kings and Lows)
        if (wildRules.LowestCardIsWild && _isSeated && CurrentPlayerHandCards.Count > 0)
        {
            var lowestCard = GetLowestCard(CurrentPlayerHandCards);
            if (lowestCard is not null)
            {
                wildCards.Add(new TableCanvas.WildCardDisplay(
                    Rank: lowestCard.Rank,
                    Suit: null,
                    Label: "Your Lowest",
                    IsPersonalized: true
                ));
            }
        }

        return wildCards;
    }

    /// <summary>
    /// Gets a display-friendly name for a rank.
    /// </summary>
    private static string GetDisplayRankName(string? rank) => rank?.ToUpperInvariant() switch
    {
        "A" => "Ace",
        "K" => "King",
        "Q" => "Queen",
        "J" => "Jack",
        "10" or "T" => "10",
        _ => rank ?? "?"
    };

    /// <summary>
    /// Gets a label for a wild rank (e.g., "All 3s", "Queens").
    /// </summary>
    private static string GetWildRankLabel(string? rank) => rank?.ToUpperInvariant() switch
    {
        "A" => "Aces",
        "K" => "Kings",
        "Q" => "Queens",
        "J" => "Jacks",
        "2" => "Deuces",
        "3" => "Threes",
        "4" => "Fours",
        "5" => "Fives",
        "6" => "Sixes",
        "7" => "Sevens",
        "8" => "Eights",
        "9" => "Nines",
        "10" or "T" => "Tens",
        _ => $"All {rank}s"
    };

    /// <summary>
    /// Gets the lowest card from a collection of cards (for Kings and Lows).
    /// </summary>
    private static CardInfo? GetLowestCard(IReadOnlyList<CardInfo> cards)
    {
        if (cards.Count == 0)
        {
            return null;
        }

        return cards
            .Where(c => c.IsFaceUp && !string.IsNullOrWhiteSpace(c.Rank))
            .OrderBy(c => GetCardValue(c.Rank))
            .FirstOrDefault();
    }

    /// <summary>
    /// Gets the numeric value of a card rank for comparison.
    /// </summary>
    private static int GetCardValue(string? rank) => rank?.ToUpperInvariant() switch
    {
        "A" => 14,
        "K" => 13,
        "Q" => 12,
        "J" => 11,
        "10" or "T" => 10,
        "9" => 9,
        "8" => 8,
        "7" => 7,
        "6" => 6,
        "5" => 5,
        "4" => 4,
        "3" => 3,
        "2" => 2,
        _ => 0
    };

    private static string DisplayFirstName(ShowdownPlayerHand? hand)
    {
        if (!string.IsNullOrWhiteSpace(hand?.PlayerFirstName))
        {
            return hand.PlayerFirstName;
        }

        if (string.IsNullOrWhiteSpace(hand?.PlayerName))
        {
            return "Player";
        }

        var parts = hand.PlayerName.Trim().Split(' ', StringSplitOptions.RemoveEmptyEntries);
        return parts.Length > 0 ? parts[0] : hand.PlayerName;
    }

    /// <summary>
    /// Gets the list of player names who lost the showdown and must match the pot.
    /// </summary>
    private IReadOnlyList<string> GetLosingPlayers()
    {
        return _showdownResult?.PlayerHands?
            .Where(h => h.IsWinner == false)
            .Select(h => DisplayFirstName(h))
            .ToList() ?? [];
    }

    /// <summary>
    /// Handles pot matching acknowledgment.
    /// Calls the AcknowledgePotMatch API endpoint.
    /// </summary>
    private async Task HandlePotMatchAcknowledge()
    {
        if (_isAcknowledgingPotMatch)
        {
            return;
        }

        _isAcknowledgingPotMatch = true;
        await InvokeAsync(StateHasChanged);

        // Leverage API router which handles game type checks or throws/returns error if not supported
        try
        {
            var response = await GameApiRouter.AcknowledgePotMatchAsync(_gameTypeCode ?? "", GameId);
            if (response.IsSuccess)
            {
                Logger.LogDebug("Pot match acknowledged successfully");
                // SignalR will update the game state
            }
            else
            {
                // Only log error if it wasn't just "not supported" for a game that doesn't use it
                // But this method guarded with !IsKingsAndLows before.
                // It's cleaner to keep the guard if the UI button is only shown for KingsAndLows.
                Logger.LogError("Failed to acknowledge pot match: {StatusCode} {Error}", response.StatusCode, response.Error);
                await ShowToastAsync("Failed to acknowledge pot match.", "error");
                
                // On error, reset the flag so user can try again
                _isAcknowledgingPotMatch = false;
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error acknowledging pot match");
            await ShowToastAsync("An error occurred while acknowledging.", "error");
            
            // On error, reset the flag so user can try again
            _isAcknowledgingPotMatch = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    // Kings and Lows - Chip Check Pause methods

    /// <summary>
    /// Gets whether the current player is short on chips for the pot.
    /// </summary>
    private bool IsCurrentPlayerShortOnChips =>
    _isSeated &&
    _currentPlayerSeatIndex >= 0 &&
    _currentPlayerSeatIndex < _seats.Count &&
    _seats[_currentPlayerSeatIndex].Chips < _chipCheckPotAmount;

    /// <summary>
    /// Checks if a specific player (by seat index) is short on chips for the pot.
    /// Used to display "Waiting for chips" status to other players.
    /// </summary>
    private bool IsPlayerShortOnChips(int seatIndex, int chips)
    {
        if (!_isPausedForChipCheck || _chipCheckPotAmount <= 0)
        {
            return false;
        }

        return chips < _chipCheckPotAmount;
    }

    /// <summary>
    /// Gets the current player's chip count.
    /// </summary>
    private int GetCurrentPlayerChips()
    {
        if (_currentPlayerSeatIndex >= 0 && _currentPlayerSeatIndex < _seats.Count)
        {
            return _seats[_currentPlayerSeatIndex].Chips;
        }
        return 0;
    }

    /// <summary>
    /// Gets the list of players who are short on chips.
    /// </summary>
    private IReadOnlyList<ChipCoveragePauseOverlay.ShortPlayerInfo> GetShortPlayers()
    {
        return _seats
        .Where(s => s.IsOccupied && !s.IsSittingOut && s.Chips < _chipCheckPotAmount)
        .Select(s => new ChipCoveragePauseOverlay.ShortPlayerInfo(
        s.PlayerFirstName ?? s.PlayerName ?? "Unknown",
        s.Chips))
        .ToList();
    }

    /// <summary>
    /// Gets the number of seconds remaining on the chip check pause timer.
    /// </summary>
    private int GetChipCheckSecondsRemaining()
    {
        if (!_chipCheckPauseEndsAt.HasValue)
        {
            return 0;
        }

        var remaining = _chipCheckPauseEndsAt.Value - DateTimeOffset.UtcNow;
        return Math.Max(0, (int)remaining.TotalSeconds);
    }

    // Kings and Lows - Drop or Stay methods

    /// <summary>
    /// Gets the list of players waiting to make their drop or stay decision.
    /// </summary>
    private IReadOnlyList<string> GetPlayersWaitingForDropOrStay()
    {
        return _seats
        .Where(s => s.IsOccupied && !s.IsFolded && !s.IsSittingOut && !s.HasDecidedDropOrStay)
        .Select(s => s.PlayerFirstName ?? s.PlayerName ?? "Unknown")
        .ToList();
    }

    /// <summary>
    /// Handles drop or stay decision from the overlay.
    /// </summary>
    private async Task HandleDropOrStayDecision(string decision)
    {
        // Don't check GameTypeCode manually, rely on HasDropOrStay rule
        if (!HasDropOrStay || _isProcessingDropOrStay)
        {
            return;
        }

        _isProcessingDropOrStay = true;
        StateHasChanged();

        try
        {
            var request = new DropOrStayRequest(
            decision: decision,
            playerId: _currentPlayerId ?? Guid.Empty
            );

            var response = await KingsAndLowsApi.KingsAndLowsDropOrStayAsync(GameId, request);

            if (response.IsSuccessStatusCode)
            {
                _hasDropOrStayDecided = true;
                _dropOrStayDecision = decision;
                Logger.LogDebug("Drop or stay decision recorded: {Decision}", decision);
                // SignalR will update the game state
            }
            else
            {
                Logger.LogError("Failed to record drop or stay decision: {StatusCode}", response.StatusCode);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error recording drop or stay decision");
        }
        finally
        {
            _isProcessingDropOrStay = false;
            StateHasChanged();
        }
    }

    // Kings and Lows - Player vs Deck methods

    /// <summary>
    /// Gets the deck's cards for display in the player vs deck overlay.
    /// </summary>
    private IReadOnlyList<PlayerVsDeckOverlay.CardDto> GetDeckCards()
    {
        var deckCards = _tableState?.PlayerVsDeck?.DeckCards;
        if (deckCards is null || deckCards.Count == 0)
        {
            return [];
        }

        return deckCards
        .Select(c => new PlayerVsDeckOverlay.CardDto(c.Rank ?? "?", c.Suit ?? "Unknown"))
        .ToList();
    }

    /// <summary>
    /// Checks if the current player is the decision maker for the deck draw.
    /// </summary>
    private bool IsCurrentPlayerDeckDecisionMaker
    {
        get
        {
            var playerVsDeck = _tableState?.PlayerVsDeck;
            if (playerVsDeck is null)
            {
                return false;
            }

            // The current player is the decision maker if their seat matches
            return _currentPlayerSeatIndex == playerVsDeck.DecisionMakerSeatIndex;
        }
    }

    /// <summary>
    /// Gets the name of the player who makes the deck draw decision.
    /// </summary>
    private string GetDeckDecisionMakerName()
    {
        var playerVsDeck = _tableState?.PlayerVsDeck;
        if (playerVsDeck is null)
        {
            return "Dealer";
        }

        // Prefer first name for a friendlier display
        return !string.IsNullOrWhiteSpace(playerVsDeck.DecisionMakerFirstName)
        ? playerVsDeck.DecisionMakerFirstName
        : playerVsDeck.DecisionMakerName ?? "Dealer";
    }

    /// <summary>
    /// Gets the staying player's cards for the Player vs Deck overlay.
    /// </summary>
    private IReadOnlyList<CardInfo> GetStayingPlayerCards()
    {
        var playerVsDeck = _tableState?.PlayerVsDeck;
        if (playerVsDeck is null)
        {
            return [];
        }

        var stayingPlayerSeatIndex = playerVsDeck.StayingPlayerSeatIndex;

        // If the staying player is the current player and we have draw cards populated,
        // use those instead (they contain the full hand after the draw phase)
        if (stayingPlayerSeatIndex == _currentPlayerSeatIndex && _currentPlayerDrawCards.Count > 0)
        {
            return _currentPlayerDrawCards;
        }

        // Use the staying player's cards from the PlayerVsDeck state if available (includes newly drawn cards)
        if (playerVsDeck.StayingPlayerCards?.Count > 0)
        {
            return playerVsDeck.StayingPlayerCards
            .Select(c => new CardInfo
            {
                Rank = c.Rank,
                Suit = c.Suit,
                IsFaceUp = c.IsFaceUp,
                IsSelected = false
            })
            .ToList();
        }

        // Fallback to seat cards
        if (stayingPlayerSeatIndex >= 0 && stayingPlayerSeatIndex < _seats.Count)
        {
            return _seats[stayingPlayerSeatIndex].Cards;
        }

        return [];
    }

    /// <summary>
    /// Gets the staying player's name for the Player vs Deck overlay.
    /// </summary>
    private string? GetStayingPlayerName()
    {
        var playerVsDeck = _tableState?.PlayerVsDeck;
        if (playerVsDeck is null)
        {
            return null;
        }

        var stayingPlayerSeatIndex = playerVsDeck.StayingPlayerSeatIndex;
        if (stayingPlayerSeatIndex < 0 || stayingPlayerSeatIndex >= _seats.Count)
        {
            return playerVsDeck.StayingPlayerName;
        }

        // Prefer first name for a friendlier display
        var seat = _seats[stayingPlayerSeatIndex];
        return !string.IsNullOrWhiteSpace(seat.PlayerFirstName)
        ? seat.PlayerFirstName
        : seat.PlayerName ?? playerVsDeck.StayingPlayerName;
    }

    /// <summary>
    /// Gets the staying player's hand description for the Player vs Deck overlay.
    /// </summary>
    private string? GetStayingPlayerHandDescription()
    {
        var playerVsDeck = _tableState?.PlayerVsDeck;
        if (playerVsDeck is null)
        {
            return null;
        }

        var stayingPlayerSeatIndex = playerVsDeck.StayingPlayerSeatIndex;

        // If the staying player is the current player and we have a new hand description from the draw,
        // use that instead (it reflects the hand after drawing new cards)
        if (stayingPlayerSeatIndex == _currentPlayerSeatIndex && !string.IsNullOrWhiteSpace(_newHandDescription))
        {
            return _newHandDescription;
        }

        // Use the hand description from the PlayerVsDeck state if available
        if (!string.IsNullOrWhiteSpace(playerVsDeck.StayingPlayerHandDescription))
        {
            return playerVsDeck.StayingPlayerHandDescription;
        }

        // Fallback to seat's hand evaluation description
        if (stayingPlayerSeatIndex >= 0 && stayingPlayerSeatIndex < _seats.Count)
        {
            return _seats[stayingPlayerSeatIndex].HandEvaluationDescription;
        }

        return null;
    }

    /// <summary>
    /// Handles card selection toggle for deck draw.
    /// </summary>
    private Task HandleDeckCardSelectionToggle(int index)
    {
        if (_deckDrawSelectedIndices.Contains(index))
        {
            _deckDrawSelectedIndices.Remove(index);
        }
        else
        {
            _deckDrawSelectedIndices.Add(index);
        }
        StateHasChanged();
        return Task.CompletedTask;
    }

    /// <summary>
    /// Handles confirmation of deck draw.
    /// </summary>
    private async Task HandleDeckDrawConfirm()
    {
        if (!IsKingsAndLows || _isProcessingDeckDraw)
        {
            return;
        }

        var discardIndices = _deckDrawSelectedIndices.ToList();

        _isProcessingDeckDraw = true;
        _isDeckDrawAnimating = true;
        _deckCardsDrawn = false;
        _delayShowdownOverlay = true; // Delay showdown until animation completes

        // Clear any existing showdown result so we fetch fresh data from API after deck draw
        // This prevents stale SignalR data from being used
        _showdownResult = null;
        _showShowdownOverlay = false;

        // Initialize deck draw cards from current SignalR state for animation
        var currentDeckCards = GetDeckCards();
        _deckDrawCards = currentDeckCards
        .Select((c, i) => new CardInfo
        {
            Rank = c.Rank,
            Suit = c.Suit,
            IsFaceUp = true,
            IsSelected = discardIndices.Contains(i)
        })
        .ToList();

        StateHasChanged();

        try
        {
            // Start discard animation if there are cards to discard
            if (discardIndices.Count > 0)
            {
                _isDeckDiscardingCards = true;
                await InvokeAsync(StateHasChanged);

                // Wait for discard animation
                await Task.Delay(600);
            }

            var request = new DeckDrawRequest(
            discardIndices: discardIndices,
            playerId: _currentPlayerId ?? Guid.Empty
            );

            var response = await KingsAndLowsApi.KingsAndLowsDeckDrawAsync(GameId, request);

            if (response.IsSuccessStatusCode)
            {
                // Transition to drawing new cards animation
                _isDeckDiscardingCards = false;

                if (discardIndices.Count > 0)
                {
                    _isDeckDrawingNewCards = true;
                    _deckNewCardIndices = discardIndices;
                    await InvokeAsync(StateHasChanged);

                    // Wait for draw animation
                    await Task.Delay(700);

                    _deckCardsDrawn = true;
                    if (!string.IsNullOrWhiteSpace(response.Content.HandDescription))
                    {
                        _deckHandDescription = response.Content.HandDescription;
                    }
                    await InvokeAsync(StateHasChanged);

                    // Keep the panel visible to show the results
                    // SignalR will update the deck cards with final hand
                    await Task.Delay(TimeSpan.FromSeconds(5));

                    _isDeckDrawingNewCards = false;
                    _deckNewCardIndices = [];
                }
                else
                {
                    // Stand pat - just mark as complete
                    _deckCardsDrawn = true;
                    await InvokeAsync(StateHasChanged);

                    // Keep visible briefly
                    await Task.Delay(TimeSpan.FromSeconds(3));
                }

                _hasDeckDrawn = true;
                _deckDrawSelectedIndices.Clear();
                _deckDrawCards = []; // Clear so SignalR state takes over
                Logger.LogDebug("Deck draw completed");

                // Now show the showdown overlay after animation is complete
                _delayShowdownOverlay = false;

                // Update the local game phase from the API response so IsShowdownPhase returns true
                // (SignalR broadcast may not have arrived yet)
                if (_gameResponse is not null && response.Content is not null)
                {
                    Logger.LogDebug("HandleDeckDrawSubmittedAsync: Updating CurrentPhase from {Old} to {New}",
                    _gameResponse.CurrentPhase, response.Content.NextPhase);
                    _gameResponse = _gameResponse with { CurrentPhase = response.Content.NextPhase };
                }
                else
                {
                    Logger.LogWarning("HandleDeckDrawSubmittedAsync: Cannot update phase - _gameResponse={HasResponse}, response.Content={HasContent}",
                    _gameResponse is not null, response.Content is not null);
                }

                await TryLoadShowdownAsync();
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                Logger.LogError("Failed to process deck draw: {StatusCode}", response.StatusCode);
                _delayShowdownOverlay = false; // Clear delay on error
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error processing deck draw");
            _delayShowdownOverlay = false; // Clear delay on error
        }
        finally
        {
            _isProcessingDeckDraw = false;
            _isDeckDrawAnimating = false;
            _isDeckDiscardingCards = false;
            _isDeckDrawingNewCards = false;
            _deckCardsDrawn = false;
            _deckDrawCards = [];
            StateHasChanged();
        }
    }

    /// <summary>
    /// Callback invoked when chips are added through the chip management section.
    /// State will be automatically updated via SignalR PrivateStateUpdated event.
    /// </summary>
    private async Task OnChipsAddedAsync()
    {
        // State will be automatically refreshed via SignalR
        await Task.CompletedTask;
    }
}
