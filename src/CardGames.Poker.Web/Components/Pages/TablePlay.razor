@page "/table/{GameId:guid}"
@attribute [Authorize]
@rendermode InteractiveServer
@implements IAsyncDisposable

@using System.ComponentModel
@using CardGames.Contracts.SignalR
@using CardGames.Core.French.Cards
@using CardGames.Poker.Api.Clients
@using CardGames.Poker.Api.Contracts
@using CardGames.Poker.Evaluation
@using CardGames.Poker.Hands.HandTypes
@using CardGames.Poker.Web.Components.Shared
@using CardGames.Poker.Web.Extensions
@using CardGames.Poker.Web.Services
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.AspNetCore.Authorization
@using System.Security.Claims

@inject NavigationManager NavigationManager
@inject IFiveCardDrawApi FiveCardDrawApiClient
@inject AuthenticationStateProvider AuthenticationStateProvider
@inject GameHubClient GameHubClient
@inject DashboardState DashboardState
@inject ILogger<TablePlay> Logger
<PageTitle>Table - Friday Night Poker</PageTitle>

<!-- Connection Banner -->
<ConnectionBanner IsConnected="@isConnected" IsReconnecting="@isReconnecting" />

<!-- Toast notifications -->
@if (_toastMessages.Count > 0)
{
    <div class="toast-container">
        @foreach (var toast in _toastMessages)
        {
            <div class="toast-notification @toast.Type">
                <span class="toast-message">@toast.Message</span>
            </div>
        }
    </div>
}

<main class="table-play-main">
    <!-- Leave Table / Controls Strip -->
    <div class="table-controls-strip">
        <button class="btn btn-secondary btn-sm leave-table-btn" @onclick="LeaveTableAsync">
            <i class="fa-regular fa-arrow-left"></i>
            Leave Table
        </button>

        <div class="table-info-strip">
            <span class="table-name">@_gameResponse?.Name</span>
            @if (!string.IsNullOrWhiteSpace(_gameResponse?.GameTypeName))
            {
                <span class="table-game-type">@_gameResponse.GameTypeName</span>
            }
            <span class="table-blinds">Ante: @ante &nbsp; Min Bet: @_gameResponse?.MinBet</span>
        </div>

        <div class="table-controls-right">
            @if (!_isLoading)
            {
                if (isHost)
                {
                    <div class="host-controls">
                        @if (_gameResponse.CurrentPhase == GamePhase.WaitingForPlayers.ToString() || _gameResponse.CurrentPhase
                                        == GamePhase.WaitingToStart.ToString())
                        {
                            <a href="/table/@GameId/edit" class="btn btn-secondary btn-sm">
                                <i class="fa-regular fa-pen-to-square"></i>
                                Edit Table
                            </a>
                            <button class="btn btn-primary btn-sm" @onclick="StartGameAsync" disabled="@(!canStartGame)">
                                <i class="fa-regular fa-play"></i>
                                Start Game
                            </button>
                        }
                        else if (_gameResponse.CurrentPhase != GamePhase.Ended.ToString())
                        {
                            @if (isPaused)
                            {
                                <button class="btn btn-secondary btn-sm" @onclick="ResumeGameAsync">
                                    <i class="fa-regular fa-play"></i>
                                    Resume
                                </button>
                            }
                            else
                            {
                                <button class="btn btn-secondary btn-sm" @onclick="PauseGameAsync">
                                    <i class="fa-regular fa-pause"></i>
                                    Pause
                                </button>
                            }

                            <button class="btn btn-sm btn-end-game" @onclick="EndGameAsync">
                                <i class="fa-solid fa-octagon"></i>
                                End Game
                            </button>
                        }
                    </div>
                }
            }
            <div class="connection-indicator @(isConnected ? "connected" : "disconnected")"
                title="@(isConnected ? "Connected" : "Disconnected")">
                <span class="connection-dot"></span>
            </div>
        </div>
    </div>

    @if (!_isLoading)
    {
        var temp = "";
        <!-- Main Table Area -->
        <div class="table-play-area">
            <TableCanvas Seats="@seats" Pot="@pot" CurrentPhase="@_gameResponse?.CurrentPhase"
                CurrentPhaseDescription="@_gameResponse?.CurrentPhaseDescription"
                CurrentActorSeatIndex="@currentActorSeatIndex" DealerSeatIndex="@dealerSeatIndex"
                OnSeatClick="HandleSeatClickAsync" DisableSeatSelectionForCurrentUser="@isSeated"
                CurrentPlayerSeatIndex="@currentPlayerSeatIndex" />

            <!-- Dashboard Panel (left side) -->
            @if (isSeated)
            {
                <DashboardPanel>
                    <DashboardSection Title="Leaderboard" Icon="fa-solid fa-trophy"
                        IsExpanded="@DashboardState.IsSectionExpanded("Leaderboard")"
                        IsExpandedChanged="@(value => DashboardState.SetSectionExpanded("Leaderboard", value))">
                        <LeaderboardSection Players="@GetLeaderboardPlayers()" />
                    </DashboardSection>

                    <DashboardSection Title="Odds" Icon="fa-solid fa-chart-simple"
                        IsExpanded="@DashboardState.IsSectionExpanded("Odds")"
                        IsExpandedChanged="@(value => DashboardState.SetSectionExpanded("Odds", value))">
                        <OddsSection HandOdds="@handOdds" />
                    </DashboardSection>

                    <DashboardSection Title="Hand History" Icon="fa-solid fa-clock-rotate-left"
                        IsExpanded="@DashboardState.IsSectionExpanded("HandHistory")"
                        IsExpandedChanged="@(value => DashboardState.SetSectionExpanded("HandHistory", value))">
                        <HandHistorySection Entries="@_handHistoryEntries" />
                    </DashboardSection>
                </DashboardPanel>
            }
        </div>

        <!-- Action Panel (only shown when it's player's turn during betting) -->
        @if (isPlayerTurn && !isDrawPhase && _gameResponse.CurrentPhase != GamePhase.WaitingForPlayers.ToString() &&
            _gameResponse.CurrentPhase != GamePhase.Ended.ToString())
        {
            <ActionPanel LegalActions="@legalActions" MinBet="@currentMinBet" MaxBet="@currentMaxBet"
                CurrentBetToCall="@currentBetToCall" PlayerChips="@playerChips" TurnTimeRemaining="@turnTimeRemaining"
                OnAction="HandlePlayerActionAsync" IsSubmitting="@isSubmittingAction" />
        }

        <!-- Draw Panel (only shown when it's player's turn during draw phase) -->
        @if (isDrawPhase && (isPlayerDrawTurn || _forceShowDrawPanel))
        {
            <DrawPanel Cards="@currentPlayerDrawCards" SelectedIndices="@selectedDiscardIndices"
                OnToggleSelection="ToggleDiscardSelectionAsync" OnDraw="HandleDrawActionAsync" IsSubmitting="@isSubmittingDraw"
                IsAnimating="@isDrawAnimating" IsDiscarding="@isDiscardingCards" IsDrawing="@isDrawingNewCards"
                CardsDrawn="@cardsDrawn" NewCardIndices="@newCardIndices"
                HandDescription="@currentPlayerHandEvaluationDescription" MaxDiscards="@maxDiscards" />
        }

        <!-- Draw Phase Waiting Indicator (shown to other players during draw phase) -->
        @if (isDrawPhase && !isPlayerDrawTurn && _currentDrawPlayer is not null)
        {
            <div class="draw-phase-indicator">
                <div class="draw-phase-content">
                    <i class="fa-regular fa-cards fa-spin-pulse"></i>
                    <span>@_currentDrawPlayer.PlayerName is drawing...</span>
                </div>
            </div>
        }

        <!-- Waiting/Pre-game overlay -->
        @if (_gameResponse.CurrentPhase == GamePhase.WaitingForPlayers.ToString())
        {
            <div class="table-overlay waiting-overlay">
                <div class="overlay-content">
                    <div class="overlay-icon"><i class="fa-solid fa-clock"></i></div>
                    <h2>Waiting for Players</h2>
                    <p>@seatedPlayerCount / @_gameResponse.MinimumNumberOfPlayers players seated</p>
                    <div class="ready-status">
                        @foreach (var seat in seats.Where(s => s.IsOccupied))
                        {
                            <div class="ready-player @(seat.IsReady ? "is-ready" : "")">
                                <span class="ready-avatar">@GetInitials(seat.PlayerName)</span>
                                <span class="ready-name">@seat.PlayerName</span>
                                @if (seat.IsReady)
                                {
                                    <span class="ready-badge">? Ready</span>
                                }
                            </div>
                        }
                    </div>
                    @if (!isSeated)
                    {
                        <p class="overlay-hint">Click an empty seat to join the table</p>
                    }
                    else if (!isReady)
                    {
                        <button class="btn btn-primary btn-lg" @onclick="SetReadyAsync">
                            <i class="fa-regular fa-check"></i>
                            I'm Ready
                        </button>
                    }
                    else
                    {
                        <p class="overlay-hint">Waiting for other players...</p>
                    }
                </div>
            </div>
        }

        <!-- Game Ended overlay -->
        @if (_gameResponse.CurrentPhase == GamePhase.Ended.ToString())
        {
            <div class="table-overlay ended-overlay">
                <div class="overlay-content">
                    <div class="overlay-icon"><i class="fa-solid fa-circle-xmark"></i></div>
                    <h2>Game Over</h2>
                    <p>Thanks for playing!</p>
                    <div class="final-standings">
                        @foreach (var seat in seats.Where(s => s.IsOccupied).OrderByDescending(s => s.Chips))
                        {
                            <div class="standing-row">
                                <span class="standing-avatar">@GetInitials(seat.PlayerName)</span>
                                <span class="standing-name">@seat.PlayerName</span>
                                <span class="standing-chips">@seat.Chips.ToString("N0") chips</span>
                            </div>
                        }
                    </div>
                    <button class="btn btn-primary btn-lg" @onclick="LeaveTableAsync">
                        Return to Lobby
                    </button>
                </div>
            </div>
        }

        <!-- Paused overlay -->
        @if (isPaused && _gameResponse.CurrentPhase != GamePhase.WaitingForPlayers.ToString() && _gameResponse.CurrentPhase
            != GamePhase.Ended.ToString())
        {
            <div class="table-overlay paused-overlay">
                <div class="overlay-content">
                    <div class="overlay-icon"><i class="fa-solid fa-circle-pause"></i></div>
                    <h2>Game Paused</h2>
                    <p>The host has paused the game</p>
                </div>
            </div>
        }

        @if (IsShowdownPhase && _showShowdownOverlay && _showdownResult is not null)
        {
            <ShowdownOverlay ShowdownResult="@_showdownResult" ShowdownWon="@_showdownWon" ShowdownLost="@_showdownLost"
                SecondsUntilNextHand="@_secondsUntilNextHand" OnClose="@CloseShowdownOverlay" />
        }
    }
</main>

@code {
    [Parameter]
    public Guid GameId { get; set; }

    // Connection state (driven by SignalR)
    private bool isConnected = false;
    private bool isReconnecting;

    private bool _isLoading = true;

    // Table info
    private int ante = 5;

    // Game state
    private bool isPaused;
    private int pot; // TODO: Get from server
    private int dealerSeatIndex = 0;
    private int currentActorSeatIndex = -1;

    // Player state
    private bool isHost; // Determined from game creator
    private bool isSeated;
    private bool isReady;
    private int currentPlayerSeatIndex = -1;
    private int playerChips = 1000; // TODO: Get from server
    private bool isPlayerTurn;
    private bool isSubmittingAction;

    private string? currentPlayerName; // TODO: Get from auth
    private Guid? _currentPlayerId; // Player ID for API calls (hand history, etc.)

    // Action state
    private List<BettingActionType> legalActions = [];
    private int currentMinBet;
    private int currentMaxBet;
    private int currentBetToCall;
    private int turnTimeRemaining = 30; // TODO: Get from server

    private AvailableActionsResponse? _availableActions;
    private GetCurrentBettingRoundResponse? _currentBettingRound;

    // Draw phase state
    private bool isDrawPhase;
    private bool isPlayerDrawTurn;
    private bool isSubmittingDraw;
    private bool isDrawAnimating;
    private bool isDiscardingCards;
    private bool isDrawingNewCards;
    private bool cardsDrawn;
    private List<int> newCardIndices = [];
    private HashSet<int> selectedDiscardIndices = [];
    private List<CardInfo> currentPlayerDrawCards = [];
    private GetCurrentDrawPlayerResponse? _currentDrawPlayer;
    private bool _forceShowDrawPanel;
    private int maxDiscards = 3;

    private string? currentPlayerHandEvaluationDescription =>
    currentPlayerSeatIndex >= 0 && currentPlayerSeatIndex < seats.Count
    ? seats[currentPlayerSeatIndex].HandEvaluationDescription
    : null;

    // Showdown state
    private PerformShowdownSuccessful? _showdownResult;
    private bool _showShowdownOverlay;
    private bool _showdownWon;
    private bool _showdownLost;

    // Continuous play state
    private int _secondsUntilNextHand;
    private bool _isResultsPhase;
    private System.Threading.Timer? _countdownTimer;

    // Hand odds state
    private List<HandTypeOddsDto> handOdds = [];

    // Dashboard / Hand history state
    private List<HandHistoryEntryDto> _handHistoryEntries = [];
    private int _handNumber = 0;

    // Toast notification state
    private List<ToastMessage> _toastMessages = [];

    private List<SeatInfo> seats = [];

    private int seatedPlayerCount;
    private bool canStartGame;

    private bool _initialized;

    private string? _loggedInUserEmail;

    private bool IsCompletePhase => string.Equals(_gameResponse?.CurrentPhase, "Complete",
    StringComparison.OrdinalIgnoreCase);

    private bool IsShowdownPhase => string.Equals(_gameResponse?.CurrentPhase, GamePhase.Showdown.ToString(),
    StringComparison.OrdinalIgnoreCase)
    || string.Equals(_gameResponse?.CurrentPhase, "Showdown", StringComparison.OrdinalIgnoreCase)
    || IsCompletePhase;

    protected override async Task OnInitializedAsync()
    {
        if (_initialized)
        {
            return;
        }

        _initialized = true;
        InitializeSeats();

        // Subscribe to SignalR events
        GameHubClient.OnTableStateUpdated += HandleTableStateUpdatedAsync;
        GameHubClient.OnPrivateStateUpdated += HandlePrivateStateUpdatedAsync;
        GameHubClient.OnPlayerJoined += HandlePlayerJoinedAsync;
        GameHubClient.OnConnectionStateChanged += HandleConnectionStateChanged;

        // Load initial data FIRST so seats and _gameResponse are populated
        // before SignalR sends its state snapshot
        await LoadDataAsync();

        // Connect to SignalR hub and join game - the snapshot will now
        // be processed correctly since seats are already populated
        await ConnectAndJoinGameAsync();
    }

    private async Task ConnectAndJoinGameAsync()
    {
        try
        {
            await GameHubClient.ConnectAsync();
            isConnected = GameHubClient.IsConnected;
            await GameHubClient.JoinGameAsync(GameId);
            Logger.LogInformation("Connected to SignalR and joined game {GameId}", GameId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to connect to SignalR hub for game {GameId}", GameId);
            isConnected = false;
        }
    }

    private void HandleConnectionStateChanged(Microsoft.AspNetCore.SignalR.Client.HubConnectionState state)
    {
        isConnected = state == Microsoft.AspNetCore.SignalR.Client.HubConnectionState.Connected;
        isReconnecting = state == Microsoft.AspNetCore.SignalR.Client.HubConnectionState.Reconnecting;
        _ = InvokeAsync(StateHasChanged);
    }

    private async Task HandlePlayerJoinedAsync(PlayerJoinedDto notification)
    {
        if (notification.GameId != GameId)
        {
            return;
        }

        Logger.LogDebug("Player {PlayerName} joined at seat {SeatIndex}", notification.PlayerName, notification.SeatIndex);

        // Show toast notification to other players
        await ShowToastAsync(notification.Message, "info");
    }

    private async Task ShowToastAsync(string message, string type = "info", int durationMs = 4000)
    {
        var toast = new ToastMessage(message, type);
        _toastMessages.Add(toast);
        await InvokeAsync(StateHasChanged);

        // Auto-dismiss after duration
        _ = Task.Run(async () =>
        {
            await Task.Delay(durationMs);
            _toastMessages.Remove(toast);
            await InvokeAsync(StateHasChanged);
        });
    }

    private async Task HandleTableStateUpdatedAsync(TableStatePublicDto state)
    {
        if (state.GameId != GameId)
        {
            return;
        }

        Logger.LogDebug("Received table state update for game {GameId}, phase: {Phase}", state.GameId, state.CurrentPhase);

        // Update game response fields from public state
        // Handle case where _gameResponse is not yet loaded from API
        if (_gameResponse is not null)
        {
            _gameResponse = _gameResponse with
            {
                CurrentPhase = state.CurrentPhase,
                CurrentPhaseDescription = state?.CurrentPhaseDescription ?? "",
                Name = state.Name ?? _gameResponse.Name,
                GameTypeName = state.GameTypeName ?? _gameResponse.GameTypeName,
                Ante = state.Ante,
                MinBet = state.MinBet,
                DealerPosition = state.DealerSeatIndex,
                CurrentPlayerIndex = state.CurrentActorSeatIndex
            };
        }
        else
        {
            // SignalR update arrived before LoadDataAsync completed - defer to initial load
            Logger.LogDebug("Received SignalR update before initial data loaded, skipping state update");
            return;
        }

        ante = state.Ante;
        pot = state.TotalPot;
        dealerSeatIndex = state.DealerSeatIndex;
        currentActorSeatIndex = state.CurrentActorSeatIndex;
        isPaused = state.IsPaused;

        // Update seats from public state
        UpdateSeatsFromPublicState(state.Seats);

        // Handle showdown state - check if entering showdown/complete phase
        if (state.Showdown is not null)
        {
            UpdateShowdownFromPublicState(state.Showdown);
        }

        // If entering showdown or complete phase, load showdown results via API
        if (IsShowdownPhase && _showdownResult is null)
        {
            await TryLoadShowdownAsync();
        }

        // Handle continuous play countdown
        _isResultsPhase = state.IsResultsPhase;
        _secondsUntilNextHand = state.SecondsUntilNextHand ?? 0;

        if (_isResultsPhase && _secondsUntilNextHand > 0)
        {
            StartCountdownTimer();
        }
        else if (!_isResultsPhase)
        {
            StopCountdownTimer();
            // Clear showdown overlay when new hand starts
            if (state.CurrentPhase != "Complete" && state.CurrentPhase != "Showdown")
            {
                _showShowdownOverlay = false;
                _showdownResult = null;
            }
        }

        // Update phase-dependent state
        isDrawPhase = state.CurrentPhase == "DrawPhase";

        // Note: Hand history is now updated from private state (HandlePrivateStateUpdatedAsync)
        // because it contains personalized player results (CurrentPlayerResultLabel, CurrentPlayerNetDelta)

        // Recalculate derived state
        seatedPlayerCount = seats.Count(s => s.IsOccupied);
        canStartGame = seatedPlayerCount >= (_gameResponse?.MinimumNumberOfPlayers ?? 2) &&
        seats.Where(s => s.IsOccupied).All(s => s.IsReady);

        // Update current player info
        currentPlayerSeatIndex = seats.FirstOrDefault(s => s.IsOccupied &&
        !string.IsNullOrWhiteSpace(_loggedInUserEmail) &&
        string.Equals(s.PlayerName, _loggedInUserEmail, StringComparison.OrdinalIgnoreCase))?.SeatIndex ?? -1;

        isSeated = currentPlayerSeatIndex >= 0;
        isReady = isSeated && seats[currentPlayerSeatIndex].IsReady;

        await InvokeAsync(StateHasChanged);
    }

    private async Task HandlePrivateStateUpdatedAsync(PrivateStateDto state)
    {
        if (state.GameId != GameId)
        {
            return;
        }

        Logger.LogDebug("Received private state update for player {PlayerName}", state.PlayerName);

        // Ensure we know which seat is the current player before applying private hand state.
        // When joining a game already in progress, the private snapshot can arrive before the
        // page has resolved `currentPlayerSeatIndex` via public state.
        if (currentPlayerSeatIndex < 0 && !string.IsNullOrWhiteSpace(state.PlayerName))
        {
            currentPlayerSeatIndex = seats.FindIndex(s => s.IsOccupied
            && !string.IsNullOrWhiteSpace(s.PlayerName)
            && string.Equals(s.PlayerName, state.PlayerName, StringComparison.OrdinalIgnoreCase));

            if (currentPlayerSeatIndex >= 0)
            {
                isSeated = true;
                currentPlayerName = state.PlayerName;
                seats[currentPlayerSeatIndex].IsCurrentPlayer = true;
            }
        }

        // Update player's cards
        if (currentPlayerSeatIndex >= 0 && currentPlayerSeatIndex < seats.Count)
        {
            seats[currentPlayerSeatIndex].Cards = state.Hand.Select(c => new CardInfo
            {
                Rank = c.Rank,
                Suit = c.Suit,
                IsFaceUp = true,
                IsSelected = false
            }).ToList();

            seats[currentPlayerSeatIndex].HandEvaluationDescription = state.HandEvaluationDescription;
        }

        // Update available actions
        if (state.AvailableActions is not null)
        {
            _availableActions = new AvailableActionsResponse(
            callAmount: state.AvailableActions.CallAmount,
            canAllIn: state.AvailableActions.CanAllIn,
            canBet: state.AvailableActions.CanBet,
            canCall: state.AvailableActions.CanCall,
            canCheck: state.AvailableActions.CanCheck,
            canFold: state.AvailableActions.CanFold,
            canRaise: state.AvailableActions.CanRaise,
            maxBet: state.AvailableActions.MaxBet,
            minBet: state.AvailableActions.MinBet,
            minRaise: state.AvailableActions.MinRaise
            );

            isPlayerTurn = state.IsMyTurn;
            if (state.IsMyTurn)
            {
                legalActions = MapLegalActionsFromPrivateState(state.AvailableActions);
                currentMinBet = Math.Max(_gameResponse?.MinBet ?? 0, state.AvailableActions.MinBet);
                currentMaxBet = state.AvailableActions.MaxBet;
                currentBetToCall = state.AvailableActions.CallAmount;
            }
        }
        else
        {
            isPlayerTurn = state.IsMyTurn && isDrawPhase; // May be draw turn
            if (!isDrawPhase)
            {
                legalActions = [];
            }
        }

        // Update draw phase state
        if (state.Draw is not null)
        {
            isPlayerDrawTurn = state.Draw.IsMyTurnToDraw;
            maxDiscards = state.Draw.MaxDiscards;
            if (state.Draw.IsMyTurnToDraw && !isDrawAnimating && !_forceShowDrawPanel)
            {
                currentPlayerDrawCards = state.Hand.Select((c, i) => new CardInfo
                {
                    Rank = c.Rank,
                    Suit = c.Suit,
                    IsFaceUp = true,
                    IsSelected = selectedDiscardIndices.Contains(i)
                }).ToList();
            }
            else if ((isDrawAnimating || _forceShowDrawPanel) && currentPlayerDrawCards.Count == 0)
            {
                // Preserve whatever is currently being animated. If we lost the list for any reason,
                // fall back to the latest private hand state to keep the panel populated.
                currentPlayerDrawCards = state.Hand.Select((c, i) => new CardInfo
                {
                    Rank = c.Rank,
                    Suit = c.Suit,
                    IsFaceUp = true,
                    IsSelected = selectedDiscardIndices.Contains(i)
                }).ToList();
            }
        }

        // Calculate hand odds from current cards
        CalculateHandOdds(state.Hand);

        // Update hand history from private state (contains personalized player results)
        if (state.HandHistory is not null && state.HandHistory.Count > 0)
        {
            _handHistoryEntries = state.HandHistory.ToList();
        }

        await InvokeAsync(StateHasChanged);
    }

    private void UpdateSeatsFromPublicState(IReadOnlyList<SeatPublicDto> publicSeats)
    {
        foreach (var publicSeat in publicSeats)
        {
            if (publicSeat.SeatIndex >= 0 && publicSeat.SeatIndex < seats.Count)
            {
                var isCurrentPlayer = !string.IsNullOrWhiteSpace(_loggedInUserEmail) &&
                string.Equals(publicSeat.PlayerName, _loggedInUserEmail, StringComparison.OrdinalIgnoreCase);

                // Preserve face-up cards for current player (will be updated by private state)
                var existingCards = seats[publicSeat.SeatIndex].Cards;
                var cards = isCurrentPlayer && existingCards.Any()
                ? existingCards
                : publicSeat.Cards.Select(c => new CardInfo
                {
                    Rank = c.IsFaceUp ? c.Rank : null,
                    Suit = c.IsFaceUp ? c.Suit : null,
                    IsFaceUp = c.IsFaceUp,
                    IsSelected = false
                }).ToList();

                seats[publicSeat.SeatIndex] = new SeatInfo
                {
                    SeatIndex = publicSeat.SeatIndex,
                    IsOccupied = publicSeat.IsOccupied,
                    PlayerName = publicSeat.PlayerName,
                    PlayerAvatarUrl = publicSeat.PlayerAvatarUrl,
                    PlayerFirstName = publicSeat.PlayerFirstName,
                    Chips = publicSeat.Chips,
                    IsReady = publicSeat.IsReady,
                    IsCurrentPlayer = isCurrentPlayer,
                    IsFolded = publicSeat.IsFolded,
                    IsAllIn = publicSeat.IsAllIn,
                    IsDisconnected = publicSeat.IsDisconnected,
                    IsSittingOut = publicSeat.IsSittingOut,
                    SittingOutReason = publicSeat.SittingOutReason,
                    CurrentBet = publicSeat.CurrentBet,
                    Cards = cards
                };
            }
        }
    }

    private void UpdateShowdownFromPublicState(ShowdownPublicDto showdown)
    {
        if (_showdownResult is null && showdown.IsComplete)
        {
            // Convert to existing showdown format using constructor
            var payouts = showdown.PlayerResults
            .Where(r => r.IsWinner)
            .ToDictionary(r => r.PlayerName, r => r.AmountWon);

            var playerHands = showdown.PlayerResults.Select(r => new ShowdownPlayerHand(
            amountWon: r.AmountWon,
            cards: ConvertCardsToShowdownCards(r.Cards),
            handStrength: null,
            handType: r.HandRanking ?? "",
            isWinner: r.IsWinner,
            playerFirstName: r.PlayerFirstName,
            playerName: r.PlayerName,
            handDescription: r.HandDescription ?? ""
            )).ToList();

            _showdownResult = new PerformShowdownSuccessful(
            currentPhase: "Complete",
            gameId: GameId,
            payouts: payouts,
            playerHands: playerHands,
            wonByFold: false
            );

            _showShowdownOverlay = true;

            // Check if current user is a winner by comparing against payout keys
            _showdownWon = _showdownResult.Payouts?.Keys.Any(p =>
            string.Equals(p, _loggedInUserEmail, StringComparison.OrdinalIgnoreCase) ||
            string.Equals(p, currentPlayerName, StringComparison.OrdinalIgnoreCase)) == true;
            _showdownLost = !_showdownWon;
        }
    }

    private static ICollection<ShowdownCard> ConvertCardsToShowdownCards(IReadOnlyList<CardPublicDto>? cards)
    {
        if (cards is null || cards.Count == 0)
        {
            return [];
        }

        return cards
        .Where(c => c.IsFaceUp && !string.IsNullOrWhiteSpace(c.Rank) && !string.IsNullOrWhiteSpace(c.Suit))
        .Select(c => new ShowdownCard(
        suit: ParseCardSuit(c.Suit),
        symbol: ParseCardSymbol(c.Rank)
        ))
        .ToList();
    }

    private static CardSuit? ParseCardSuit(string? suit)
    {
        if (string.IsNullOrWhiteSpace(suit))
        {
            return null;
        }

        return suit.Trim().ToLowerInvariant() switch
        {
            "hearts" or "h" => CardSuit.Hearts,
            "diamonds" or "d" => CardSuit.Diamonds,
            "spades" or "s" => CardSuit.Spades,
            "clubs" or "c" => CardSuit.Clubs,
            _ => null
        };
    }

    private static CardSymbol? ParseCardSymbol(string? rank)
    {
        if (string.IsNullOrWhiteSpace(rank))
        {
            return null;
        }

        return rank.Trim().ToUpperInvariant() switch
        {
            "2" or "TWO" or "DEUCE" => CardSymbol.Deuce,
            "3" or "THREE" => CardSymbol.Three,
            "4" or "FOUR" => CardSymbol.Four,
            "5" or "FIVE" => CardSymbol.Five,
            "6" or "SIX" => CardSymbol.Six,
            "7" or "SEVEN" => CardSymbol.Seven,
            "8" or "EIGHT" => CardSymbol.Eight,
            "9" or "NINE" => CardSymbol.Nine,
            "10" or "T" or "TEN" => CardSymbol.Ten,
            "J" or "JACK" => CardSymbol.Jack,
            "Q" or "QUEEN" => CardSymbol.Queen,
            "K" or "KING" => CardSymbol.King,
            "A" or "ACE" => CardSymbol.Ace,
            _ => null
        };
    }

    private static List<BettingActionType> MapLegalActionsFromPrivateState(AvailableActionsDto available)
    {
        var actions = new List<BettingActionType>();

        if (available.CanFold) actions.Add(BettingActionType.Fold);
        if (available.CanCheck) actions.Add(BettingActionType.Check);
        if (available.CanCall) actions.Add(BettingActionType.Call);
        if (available.CanBet) actions.Add(BettingActionType.Bet);
        if (available.CanRaise) actions.Add(BettingActionType.Raise);
        if (available.CanAllIn) actions.Add(BettingActionType.AllIn);

        return actions;
    }

    private async Task<string?> GetLoggedInUserEmailAsync()
    {
        var authState = await AuthenticationStateProvider.GetAuthenticationStateAsync();
        var user = authState.User;

        if (user.Identity?.IsAuthenticated != true)
        {
            return null;
        }

        // Common claim locations across providers.
        return user.FindFirstValue(ClaimTypes.Email)
        ?? user.FindFirstValue("email")
        ?? user.FindFirstValue("preferred_username")
        ?? user.Identity?.Name;
    }

    private void InitializeSeats()
    {
        seats = Enumerable.Range(0, 8)
        .Select(i => new SeatInfo { SeatIndex = i })
        .ToList();
    }

    private GetGameResponse? _gameResponse;
    private async Task LoadDataAsync()
    {
        try
        {
            _loggedInUserEmail ??= await GetLoggedInUserEmailAsync();
            var gameResponse = await FiveCardDrawApiClient.GetGameAsync(GameId);
            _gameResponse = gameResponse.Content;

            await GetPlayersAndUpdateSeatsAsync();

            // Load hand history for the dashboard (requires player ID from GetPlayersAndUpdateSeatsAsync)
            await LoadHandHistoryAsync();

            if (IsCompletePhase)
            {
                await TryLoadShowdownAsync();
            }

            // SignalR will handle state updates - no polling needed
            // Initial state snapshot is sent when joining the game via SignalR
        }
        finally
        {
            seatedPlayerCount = seats.Count(s => s.IsOccupied);
            canStartGame = seatedPlayerCount >= (_gameResponse?.MinimumNumberOfPlayers ?? 2) && seats.Where(s => s.IsOccupied).All(s
            => s.IsReady);

            // Determine if current user is the host (game creator)
            isHost = !string.IsNullOrWhiteSpace(_loggedInUserEmail) &&
            !string.IsNullOrWhiteSpace(_gameResponse?.CreatedByName) &&
            string.Equals(_loggedInUserEmail, _gameResponse.CreatedByName, StringComparison.OrdinalIgnoreCase);

            // Determine current player seat by matching logged-in email to seat PlayerName (case-insensitive).
            currentPlayerName ??= _loggedInUserEmail;
            currentPlayerSeatIndex = seats.FirstOrDefault(s => s.IsOccupied &&
            !string.IsNullOrWhiteSpace(currentPlayerName) &&
            string.Equals(s.PlayerName, currentPlayerName, StringComparison.OrdinalIgnoreCase))?.SeatIndex ?? -1;

            isSeated = currentPlayerSeatIndex >= 0;
            isReady = isSeated && seats[currentPlayerSeatIndex].IsReady;
            _isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task GetPlayersAndUpdateSeatsAsync()
    {
        var playersResponse = await FiveCardDrawApiClient.GetGamePlayersAsync(GameId);
        if (playersResponse is { IsSuccessStatusCode: true, Content: not null })
        {
            var players = playersResponse.Content.ToList();
            //TODO:ROB - Check for nulls and errors
            for (int i = 0; i < players.Count && i < seats.Count; i++)
            {
                var currentUserMatch = currentPlayerName ?? _loggedInUserEmail;
                var isCurrentPlayer = !string.IsNullOrWhiteSpace(currentUserMatch) &&
                string.Equals(players[i].PlayerName, currentUserMatch, StringComparison.OrdinalIgnoreCase);

                // Capture the current player's ID for API calls
                if (isCurrentPlayer)
                {
                    _currentPlayerId = players[i].PlayerId;
                }

                seats[i] = new SeatInfo
                {
                    SeatIndex = i,
                    IsOccupied = true,
                    PlayerName = players[i].PlayerName,
                    PlayerAvatarUrl = players[i].PlayerAvatarUrl,
                    PlayerFirstName = players[i].PlayerFirstName,
                    Chips = players[i].StartingChips,
                    IsReady = players[i].Status == GamePlayerStatus.Active,
                    IsCurrentPlayer = isCurrentPlayer,
                    Cards = players[i].Hand.OrderBy(c => c.DealOrder).Select(c => new CardInfo
                    {
                        Rank = c.Symbol.ToCardRankString(),
                        Suit = c.Suit.ToCardSuitString(),
                        IsFaceUp = isCurrentPlayer,
                        IsSelected = false
                    }).ToList()
                };
            }

            currentPlayerSeatIndex = seats.FirstOrDefault(s => s.IsCurrentPlayer)?.SeatIndex ?? currentPlayerSeatIndex;
        }
        else
        {
            // Handle error (e.g., show message)
        }
    }

    /// <summary>
    /// Loads hand history from the API for initial page load.
    /// </summary>
    private async Task LoadHandHistoryAsync()
    {
        try
        {
            var response = await FiveCardDrawApiClient.GetHandHistoryAsync(
            GameId,
            take: 25,
            skip: 0,
            playerId: _currentPlayerId);

            if (response is { IsSuccessStatusCode: true, Content.Entries: not null })
            {
                _handHistoryEntries = response.Content.Entries.ToList();
                Logger.LogInformation("Loaded {Count} hand history entries for game {GameId}", _handHistoryEntries.Count, GameId);

                // Debug log each entry
                foreach (var entry in _handHistoryEntries)
                {
                    Logger.LogInformation("HandHistory API: Hand #{HandNumber}, WinnerName='{WinnerName}', AmountWon={AmountWon}, ResultLabel='{ResultLabel}'",
                    entry.HandNumber, entry.WinnerName ?? "(null)", entry.AmountWon, entry.CurrentPlayerResultLabel ?? "(null)");
                }
            }
            else
            {
                Logger.LogWarning("GetHandHistoryAsync returned unsuccessful: StatusCode={StatusCode}, HasContent={HasContent}",
                response?.StatusCode, response?.Content is not null);
            }
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to load hand history for game {GameId}", GameId);
        }
    }

    private async Task LeaveTableAsync()
    {
        // Leave SignalR game group before navigating away
        await GameHubClient.LeaveGameAsync(GameId);
        NavigationManager.NavigateTo("/lobby");
    }

    private async Task HandleSeatClickAsync(int seatIndex)
    {
        if (isSeated || seats[seatIndex].IsOccupied)
            return;

        try
        {
            // Call the API to join the game at this seat
            var request = new CardGames.Poker.Api.Clients.JoinGameRequest(seatIndex, 1000);
            var response = await FiveCardDrawApiClient.JoinGameAsync(GameId, request);

            if (!response.IsSuccessStatusCode)
            {
                Logger.LogWarning(
                                                    "Failed to join game at seat {SeatIndex}: {StatusCode} - {Error}",
                seatIndex, response.StatusCode, response.Error?.Content);
                return;
            }

            // Update local state - SignalR will also broadcast the update
            _loggedInUserEmail ??= await GetLoggedInUserEmailAsync();
            seats[seatIndex] = new SeatInfo
            {
                SeatIndex = seatIndex,
                IsOccupied = true,
                PlayerName = response.Content?.PlayerName ?? _loggedInUserEmail ?? "You",
                PlayerAvatarUrl = response.Content?.PlayerAvatarUrl,
                PlayerFirstName = response.Content?.PlayerFirstName,
                Chips = 1000,
                IsCurrentPlayer = true,
                IsReady = false
            };
            isSeated = true;
            currentPlayerSeatIndex = seatIndex;

            Logger.LogInformation(
                                        "Successfully joined game {GameId} at seat {SeatIndex}. CanPlayCurrentHand: {CanPlay}",
            GameId, seatIndex, response.Content?.CanPlayCurrentHand);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error joining game at seat {SeatIndex}", seatIndex);
        }
    }

    private async Task SetReadyAsync()
    {
        // TODO: Send ready request to server
        isReady = true;
        if (currentPlayerSeatIndex >= 0)
        {
            seats[currentPlayerSeatIndex].IsReady = true;
        }
        await Task.CompletedTask;
    }

    private async Task StartGameAsync()
    {
        if (!isHost || !canStartGame)
        {
            return;
        }

        isSubmittingAction = false;
        isPlayerTurn = false;

        var startHandResponse = await FiveCardDrawApiClient.StartHandAsync(GameId);
        if (!startHandResponse.IsSuccessStatusCode)
        {
            return;
        }

        var collectAntesResponse = await FiveCardDrawApiClient.CollectAntesAsync(GameId);
        if (!collectAntesResponse.IsSuccessStatusCode)
        {
            return;
        }

        var dealHandsResponse = await FiveCardDrawApiClient.DealHandsAsync(GameId);
        if (!dealHandsResponse.IsSuccessStatusCode)
        {
            return;
        }

        // SignalR will broadcast the updated state - no need to refresh manually
        await TryLoadShowdownAsync();
    }

    // Polling methods removed - SignalR handles state updates

    private async Task TryLoadShowdownAsync()
    {
        if (!IsShowdownPhase)
        {
            return;
        }

        if (_showdownResult is not null)
        {
            return;
        }

        _loggedInUserEmail ??= await GetLoggedInUserEmailAsync();

        var showdownResponse = await FiveCardDrawApiClient.PerformShowdownAsync(GameId);
        if (showdownResponse is not { IsSuccessStatusCode: true, Content: not null })
        {
            return;
        }

        _showdownResult = showdownResponse.Content;
        _showShowdownOverlay = true;

        if (string.IsNullOrWhiteSpace(_loggedInUserEmail) && string.IsNullOrWhiteSpace(currentPlayerName))
        {
            _showdownWon = false;
            _showdownLost = false;
            return;
        }

        // Check against both email and display name since payout keys may use either
        var iWon = _showdownResult.Payouts?.Keys.Any(p =>
        string.Equals(p, _loggedInUserEmail, StringComparison.OrdinalIgnoreCase) ||
        string.Equals(p, currentPlayerName, StringComparison.OrdinalIgnoreCase)) == true;
        _showdownWon = iWon;
        _showdownLost = !iWon;
    }

    private void CloseShowdownOverlay()
    {
        _showShowdownOverlay = false;
    }

    private static List<BettingActionType> MapLegalActions(AvailableActionsResponse available)
    {
        var actions = new List<BettingActionType>();

        if (available.CanFold) actions.Add(BettingActionType.Fold);
        if (available.CanCheck) actions.Add(BettingActionType.Check);
        if (available.CanCall) actions.Add(BettingActionType.Call);
        if (available.CanBet) actions.Add(BettingActionType.Bet);
        if (available.CanRaise) actions.Add(BettingActionType.Raise);
        if (available.CanAllIn) actions.Add(BettingActionType.AllIn);

        return actions;
    }

    private async Task PauseGameAsync()
    {
        if (!isHost)
        {
            return;
        }

        // TODO: Send pause request to server
        isPaused = true;
        await Task.CompletedTask;
    }

    private async Task ResumeGameAsync()
    {
        if (!isHost)
            return;

        // TODO: Send resume request to server
        isPaused = false;
        await Task.CompletedTask;
    }

    private async Task EndGameAsync()
    {
        if (!isHost)
            return;

        //TODO: Send end game request to server
        //_gameResponse.CurrentPhase = GamePhase.Ended;
        await Task.CompletedTask;
    }

    private async Task HandlePlayerActionAsync(PlayerActionRequest action)
    {
        if (!isPlayerTurn || isSubmittingAction)
            return;

        isSubmittingAction = true;

        try
        {
            var request = new ProcessBettingActionRequest(action.Action, action.Amount ?? 0);
            var response = await FiveCardDrawApiClient.ProcessBettingActionAsync(GameId, request);
            if (!response.IsSuccessStatusCode)
            {
                return;
            }

            // SignalR will broadcast the updated state - no need to refresh manually
        }
        finally
        {
            isSubmittingAction = false;
        }
    }

    private async Task HandleDrawActionAsync(List<int> discardIndices)
    {
        if (!isPlayerDrawTurn || isSubmittingDraw)
            return;

        selectedDiscardIndices.Clear();
        foreach (var i in discardIndices)
        {
            selectedDiscardIndices.Add(i);
        }

        isSubmittingDraw = true;
        isDrawAnimating = true;
        _forceShowDrawPanel = true;
        cardsDrawn = false;

        try
        {
            // Start discard animation
            if (discardIndices.Count > 0)
            {
                isDiscardingCards = true;

                // Mark selected cards visually for animation
                for (int i = 0; i < currentPlayerDrawCards.Count; i++)
                {
                    if (discardIndices.Contains(i))
                    {
                        currentPlayerDrawCards[i] = currentPlayerDrawCards[i] with { IsSelected = true };
                    }
                }
                await InvokeAsync(StateHasChanged);

                // Wait for discard animation
                await Task.Delay(600);
            }

            // Make the API call
            var request = new ProcessDrawRequest(discardIndices);
            var response = await FiveCardDrawApiClient.ProcessDrawAsync(GameId, request);

            if (!response.IsSuccessStatusCode)
            {
                // Reset state on failure
                isDiscardingCards = false;
                isDrawAnimating = false;
                isSubmittingDraw = false;
                return;
            }

            var result = response.Content;

            // Transition to drawing new cards animation
            isDiscardingCards = false;

            if (discardIndices.Count > 0)
            {
                // Swap in the newly dealt cards before the draw-in animation starts
                // so the cards that animate back in display the new values.
                if (result is not null)
                {
                    var newCards = result.NewCards?.ToList() ?? [];

                    for (var i = 0; i < discardIndices.Count && i < newCards.Count; i++)
                    {
                        var targetIndex = discardIndices[i];
                        if (targetIndex < 0 || targetIndex >= currentPlayerDrawCards.Count)
                        {
                            continue;
                        }

                        var newCard = newCards[i];

                        currentPlayerDrawCards[targetIndex] = new CardInfo
                        {
                            Rank = newCard.Symbol?.ToCardRankString(),
                            Suit = newCard.Suit?.ToCardSuitString(),
                            IsFaceUp = true,
                            IsSelected = false
                        };
                    }

                    await InvokeAsync(StateHasChanged);
                }

                isDrawingNewCards = true;
                newCardIndices = discardIndices;
                await InvokeAsync(StateHasChanged);

                // Wait for the draw-in animation to complete, then switch the status out of "Drawing...".
                await Task.Delay(700);
                cardsDrawn = true;
                await InvokeAsync(StateHasChanged);

                // Keep the panel visible for the remainder of the reveal window.
                await Task.Delay(TimeSpan.FromSeconds(7) - TimeSpan.FromMilliseconds(700));

                isDrawingNewCards = false;
                newCardIndices = [];
            }

            // Clear animation state
            isDrawAnimating = false;
            currentPlayerDrawCards = [];
            selectedDiscardIndices.Clear();
            _forceShowDrawPanel = false;
            cardsDrawn = false;

            // SignalR will broadcast the updated state - no need to refresh manually
        }
        finally
        {
            isSubmittingDraw = false;
            isDiscardingCards = false;
            isDrawingNewCards = false;
            isDrawAnimating = false;
            _forceShowDrawPanel = false;
            cardsDrawn = false;
        }
    }

    private Task ToggleDiscardSelectionAsync(int index)
    {
        if (index < 0 || index >= currentPlayerDrawCards.Count)
        {
            return Task.CompletedTask;
        }

        if (!selectedDiscardIndices.Add(index))
        {
            selectedDiscardIndices.Remove(index);
        }

        currentPlayerDrawCards[index] = currentPlayerDrawCards[index] with
        {
            IsSelected = selectedDiscardIndices.Contains(index)
        };

        // Recalculate odds based on cards being kept (not selected for discard)
        RecalculateDrawOddsForSelection();

        return InvokeAsync(StateHasChanged);
    }

    /// <summary>
    /// Recalculates the hand odds based on the current discard selection.
    /// Cards not selected for discard are kept, and the odds are calculated
    /// by simulating drawing replacement cards for the discarded ones.
    /// </summary>
    private void RecalculateDrawOddsForSelection()
    {
        try
        {
            // Get the cards being kept (not selected for discard)
            var cardsToKeep = currentPlayerDrawCards
            .Where((card, index) => !selectedDiscardIndices.Contains(index))
            .Select(c => ConvertToCard(c.Rank ?? "", c.Suit ?? ""))
            .Where(c => c is not null)
            .Cast<Card>()
            .ToList();

            if (cardsToKeep.Count == 0)
            {
                handOdds = [];
                return;
            }

            // Get dead cards: cards selected for discard + folded players' visible cards
            var discardedCards = currentPlayerDrawCards
            .Where((card, index) => selectedDiscardIndices.Contains(index))
            .Select(c => ConvertToCard(c.Rank ?? "", c.Suit ?? ""))
            .Where(c => c is not null)
            .Cast<Card>()
            .ToList();

            var foldedPlayerCards = seats
            .Where(s => s.IsFolded && s.Cards.Any())
            .SelectMany(s => s.Cards)
            .Where(c => c.IsFaceUp && c.Rank is not null && c.Suit is not null)
            .Select(c => ConvertToCard(c.Rank!, c.Suit!))
            .Where(c => c is not null)
            .Cast<Card>()
            .ToList();

            // Discarded cards are dead cards (they won't be redrawn)
            var deadCards = discardedCards.Concat(foldedPlayerCards).ToList();

            var result = OddsCalculator.CalculateDrawOdds(cardsToKeep, deadCards);
            handOdds = ConvertToHandTypeOddsDtos(result);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to recalculate hand odds for discard selection");
            handOdds = [];
        }
    }

    /// <summary>
    /// Gets the leaderboard players from the current seats.
    /// </summary>
    private IReadOnlyList<LeaderboardSection.LeaderboardPlayer> GetLeaderboardPlayers()
    {
        return seats
        .Where(s => s.IsOccupied && s.PlayerName is not null)
        .Select(s => new LeaderboardSection.LeaderboardPlayer(
        PlayerId: s.SeatIndex.ToString(),
        PlayerName: s.PlayerName!,
        Chips: s.Chips))
        .OrderByDescending(p => p.Chips)
        .ToList();
    }

    private static string GetInitials(string? name)
    {
        if (string.IsNullOrWhiteSpace(name))
            return "?";

        var parts = name.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        return parts.Length switch
        {
            0 => "?",
            1 => parts[0][..1].ToUpperInvariant(),
            _ => $"{parts[0][0]}{parts[^1][0]}".ToUpperInvariant()
        };
    }

    // Enums and Models
    public enum GamePhase
    {
        [Description("Waiting for Players")] WaitingForPlayers,
        [Description("Betting Round")] Dealing,
        [Description("Pre-Draw")] PreDraw,
        [Description("Drawing")] Drawing,
        [Description("Post-Draw")] PostDraw,
        [Description("Showdown")] Showdown,
        [Description("Ended")] Ended,
        [Description("Waiting to Start")] WaitingToStart,
        [Description("Complete")] Complete,
        [Description("Second Betting Round")] SecondBettingRound,
        [Description("Draw Phase")] DrawPhase,
        [Description("First Betting Round")] FirstBettingRound,
        [Description("Collecting Antes")] CollectingAntes,
    }

    public record SeatInfo
    {
        public int SeatIndex { get; init; }
        public bool IsOccupied { get; set; }
        public string? PlayerName { get; set; }
        public string? PlayerFirstName { get; set; }
        public string? PlayerAvatarUrl { get; set; }
        public int Chips { get; set; }
        public bool IsReady { get; set; }
        public bool IsCurrentPlayer { get; set; }
        public bool IsFolded { get; set; }
        public bool IsAllIn { get; set; }
        public bool IsDisconnected { get; set; }
        public bool IsSittingOut { get; set; }
        public string? SittingOutReason { get; set; }
        public int CurrentBet { get; set; }
        public List<CardInfo> Cards { get; set; } = [];
        public string? HandEvaluationDescription { get; set; }
    }

    public record CardInfo
    {
        public string? Rank { get; init; }
        public string? Suit { get; init; }
        public bool IsFaceUp { get; init; }
        public bool IsSelected { get; init; }
    }

    public record PlayerActionRequest(BettingActionType Action, int? Amount);

    public record ToastMessage(string Message, string Type);

    private void StartCountdownTimer()
    {
        // Only start if not already running
        if (_countdownTimer is not null)
        {
            return;
        }

        _countdownTimer = new System.Threading.Timer(async _ =>
        {
            if (_secondsUntilNextHand > 0)
            {
                _secondsUntilNextHand--;
                await InvokeAsync(StateHasChanged);
            }
            else
            {
                StopCountdownTimer();
            }
        }, null, TimeSpan.FromSeconds(1), TimeSpan.FromSeconds(1));
    }

    private void StopCountdownTimer()
    {
        _countdownTimer?.Dispose();
        _countdownTimer = null;
    }

    public async ValueTask DisposeAsync()
    {
        // Stop countdown timer
        StopCountdownTimer();

        // Unsubscribe from SignalR events
        GameHubClient.OnTableStateUpdated -= HandleTableStateUpdatedAsync;
        GameHubClient.OnPrivateStateUpdated -= HandlePrivateStateUpdatedAsync;
        GameHubClient.OnPlayerJoined -= HandlePlayerJoinedAsync;
        GameHubClient.OnConnectionStateChanged -= HandleConnectionStateChanged;

        // Leave the game and disconnect
        if (_currentGameId.HasValue)
        {
            await GameHubClient.LeaveGameAsync(_currentGameId.Value);
        }
    }

    private Guid? _currentGameId => GameId;

    /// <summary>
    /// Calculates the hand odds locally using the OddsCalculator.
    /// </summary>
    private void CalculateHandOdds(IReadOnlyList<CardPrivateDto> playerCards)
    {
        if (playerCards.Count == 0)
        {
            handOdds = [];
            return;
        }

        try
        {
            // Convert CardPrivateDto to Card
            var coreCards = playerCards
            .Select(c => ConvertToCard(c.Rank, c.Suit))
            .Where(c => c is not null)
            .Cast<Card>()
            .ToList();

            if (coreCards.Count == 0)
            {
                handOdds = [];
                return;
            }

            // Get dead cards from folded players' visible cards
            var deadCards = seats
            .Where(s => s.IsFolded && s.Cards.Any())
            .SelectMany(s => s.Cards)
            .Where(c => c.IsFaceUp && c.Rank is not null && c.Suit is not null)
            .Select(c => ConvertToCard(c.Rank!, c.Suit!))
            .Where(c => c is not null)
            .Cast<Card>()
            .ToList();

            var result = OddsCalculator.CalculateDrawOdds(coreCards, deadCards);

            handOdds = ConvertToHandTypeOddsDtos(result);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "Failed to calculate hand odds");
            handOdds = [];
        }
    }

    private static Card? ConvertToCard(string rank, string suit)
    {
        var symbolValue = rank.ToUpperInvariant() switch
        {
            "A" => 14,
            "K" => 13,
            "Q" => 12,
            "J" => 11,
            "10" or "T" => 10,
            "9" => 9,
            "8" => 8,
            "7" => 7,
            "6" => 6,
            "5" => 5,
            "4" => 4,
            "3" => 3,
            "2" => 2,
            _ => 0
        };

        if (symbolValue == 0)
        {
            return null;
        }

        var suitValue = suit.ToLowerInvariant() switch
        {
            "hearts" => Suit.Hearts,
            "diamonds" => Suit.Diamonds,
            "spades" => Suit.Spades,
            "clubs" => Suit.Clubs,
            _ => (Suit?)null
        };

        if (suitValue is null)
        {
            return null;
        }

        return new Card(suitValue.Value, symbolValue);
    }

    private static List<HandTypeOddsDto> ConvertToHandTypeOddsDtos(OddsCalculator.OddsResult result)
    {
        // Order hand types from best to worst for display
        var orderedHandTypes = new[]
        {
HandType.FiveOfAKind,
HandType.StraightFlush,
HandType.Quads,
HandType.FullHouse,
HandType.Flush,
HandType.Straight,
HandType.Trips,
HandType.TwoPair,
HandType.OnePair,
HandType.HighCard
};

        return orderedHandTypes
        .Where(ht => result.HandTypeProbabilities.ContainsKey(ht))
        .Select(ht => new HandTypeOddsDto(
        HandType: ht.ToString(),
        DisplayName: GetHandTypeDisplayName(ht),
        Probability: result.HandTypeProbabilities[ht]
        ))
        .ToList();
    }

    private static string GetHandTypeDisplayName(HandType handType) => handType switch
    {
        HandType.HighCard => "High Card",
        HandType.OnePair => "One Pair",
        HandType.TwoPair => "Two Pair",
        HandType.Trips => "Three of a Kind",
        HandType.Straight => "Straight",
        HandType.Flush => "Flush",
        HandType.FullHouse => "Full House",
        HandType.Quads => "Four of a Kind",
        HandType.StraightFlush => "Straight Flush",
        HandType.FiveOfAKind => "Five of a Kind",
        _ => handType.ToString()
    };
}