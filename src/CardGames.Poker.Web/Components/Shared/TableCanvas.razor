@namespace CardGames.Poker.Web.Components.Shared

@using static CardGames.Poker.Web.Components.Pages.TablePlay

<div class="table-canvas">
    <!-- Poker table background -->
    <div class="poker-table">
        <div class="poker-table-felt">
            <!-- Center area with pot and phase -->
            <div class="table-center">
                <!-- Deck visualization -->
                <div class="deck-stack" @ref="_deckRef">
                    @for (var i = 0; i < 5; i++)
                    {
                        <playing-card rank="0" backcolor="#44F" class="deck-card" style="--deck-offset: @i"></playing-card>
                    }
                </div>

                @if (Pot > 0)
                {
                    <div class="pot-display">
                        <span class="pot-icon"><i class="fa-regular fa-coins"></i></span>
                        <span class="pot-amount">@Pot.ToString("N0")</span>
                    </div>
                }

                @if (CurrentPhase != GamePhase.WaitingForPlayers.ToString() && CurrentPhase != GamePhase.Ended.ToString())
                {
                    <div class="phase-indicator">
                        @GetPhaseLabel()
                    </div>
                }

                <!-- Community cards area (for future variants like Hold'em) -->
                <div class="community-cards">
                    @* This will be populated for Hold'em/Omaha variants *@
                </div>
            </div>
        </div>

        <!-- Seats around the table -->
        @foreach (var seat in Seats)
        {
            <div class="table-seat @GetSeatPositionClass(seat.SeatIndex) @GetSeatStateClass(seat)"
                 @onclick="() => HandleSeatClick(seat)">
                
                <TableSeat 
                    Seat="seat"
                    IsDealer="@(seat.SeatIndex == DealerSeatIndex && CurrentPhase != GamePhase.WaitingForPlayers.ToString())"
                    IsCurrentActor="@(seat.SeatIndex == CurrentActorSeatIndex)"
                    IsCurrentPlayer="@(seat.SeatIndex == CurrentPlayerSeatIndex)"
                    IsSeatSelectionDisabledForCurrentUser="@(DisableSeatSelectionForCurrentUser && !seat.IsOccupied)"
                    ShowCards="@(!IsPausedForChipCheck && CurrentPhase != GamePhase.WaitingForPlayers.ToString() && CurrentPhase != GamePhase.WaitingToStart.ToString() && seat.Cards.Count > 0)"
                    GameTypeCode="@GameTypeCode" />
            </div>
        }

        <!-- Flying card animation overlay -->
        @if (FlyingCard is not null)
        {
            var targetPosition = MapSeatIndexToDisplayPosition(FlyingCard.TargetSeatIndex);
            var isCurrentPlayerTarget = FlyingCard.TargetSeatIndex == CurrentPlayerSeatIndex;
            <div class="flying-card-container">
                <div class="flying-card @(isCurrentPlayerTarget ? "to-current-player" : "to-remote-player")"
                     style="--target-position: @targetPosition; --card-index: @FlyingCard.CardIndex;">
                    @if (FlyingCard.IsFaceUp && !string.IsNullOrWhiteSpace(FlyingCard.Rank))
                    {
                        <playing-card rank="@GetPlayingCardRank(FlyingCard.Rank)" 
                                      suit="@FlyingCard.Suit" 
                                      class="flying-card-element"></playing-card>
                    }
                    else
                    {
                        <playing-card rank="0" backcolor="#44F" class="flying-card-element"></playing-card>
                    }
                </div>
            </div>
        }
    </div>
</div>

@code {
    [Parameter]
    public List<SeatInfo> Seats { get; set; } = [];

    [Parameter]
    public int Pot { get; set; }

    [Parameter]
    public string? CurrentPhase { get; set; }

    [Parameter]
    public string? CurrentPhaseDescription { get; set; }

    [Parameter]
    public int CurrentActorSeatIndex { get; set; } = -1;

    [Parameter]
    public int DealerSeatIndex { get; set; } = -1;

    [Parameter]
    public int CurrentPlayerSeatIndex { get; set; } = -1;

    [Parameter]
    public string? GameTypeCode { get; set; }

    [Parameter]
    public bool DisableSeatSelectionForCurrentUser { get; set; }

    [Parameter]
    public bool IsPausedForChipCheck { get; set; }

    [Parameter]
    public EventCallback<int> OnSeatClick { get; set; }

    /// <summary>
    /// The currently flying card being animated from deck to player.
    /// </summary>
    [Parameter]
    public FlyingCardInfo? FlyingCard { get; set; }

    private ElementReference _deckRef;

    /// <summary>
    /// Represents a card being animated from the deck to a player's hand.
    /// </summary>
    public record FlyingCardInfo(
        int TargetSeatIndex,
        int CardIndex,
        string? Rank,
        string? Suit,
        bool IsFaceUp
    );

    private async Task HandleSeatClick(SeatInfo seat)
    {
        if (DisableSeatSelectionForCurrentUser)
        {
            return;
        }

        if (!seat.IsOccupied && OnSeatClick.HasDelegate)
        {
            await OnSeatClick.InvokeAsync(seat.SeatIndex);
        }
    }

    private string GetPhaseLabel()
    {
        return CurrentPhaseDescription ?? "Unknown";
    }

    private string GetSeatPositionClass(int seatIndex)
    {
        // Keep the seat ordering stable, but rotate the visual layout so the current player
        // is always shown at the bottom (seat-position-0).
        var positionIndex = MapSeatIndexToDisplayPosition(seatIndex);
        return $"seat-position-{positionIndex}";
    }

    private int MapSeatIndexToDisplayPosition(int seatIndex)
    {
        const int seatCount = 8;
        if (seatIndex < 0)
        {
            return seatIndex;
        }

        // If we don't know who the current player is (e.g., spectators), use the natural layout.
        if (CurrentPlayerSeatIndex < 0)
        {
            return seatIndex % seatCount;
        }

        // Rotate so the current player maps to display position 0.
        return (seatIndex - CurrentPlayerSeatIndex + seatCount) % seatCount;
    }

    private string GetSeatStateClass(SeatInfo seat)
    {
        var classes = new List<string>();

        @* if (!seat.IsOccupied)
            classes.Add("seat-empty");
        else *@
            classes.Add("seat-occupied");

        if (seat.IsCurrentPlayer)
            classes.Add("seat-current-player");

        if (seat.SeatIndex == CurrentActorSeatIndex)
            classes.Add("seat-active-turn");

        if (seat.IsFolded)
            classes.Add("seat-folded");

        if (seat.IsAllIn)
            classes.Add("seat-all-in");

        if (seat.IsDisconnected)
            classes.Add("seat-disconnected");

        return string.Join(" ", classes);
    }

    /// <summary>
    /// Converts a rank string to the playing-card web component rank attribute value.
    /// </summary>
    private static string GetPlayingCardRank(string? rank)
    {
        if (string.IsNullOrWhiteSpace(rank))
        {
            return "0";
        }

        return rank.ToUpperInvariant() switch
        {
            "A" => "1",
            "2" => "2",
            "3" => "3",
            "4" => "4",
            "5" => "5",
            "6" => "6",
            "7" => "7",
            "8" => "8",
            "9" => "9",
            "10" or "T" => "10",
            "J" => "11",
            "Q" => "12",
            "K" => "13",
            _ => "0"
        };
    }
}
