@namespace CardGames.Poker.Web.Components.Shared
@using CardGames.Contracts.SignalR
@using CardGames.Core.French.Cards
@using CardGames.Core.French.Cards.Extensions
@using CardGames.Poker.Evaluation
@using CardGames.Poker.Hands
@using CardGames.Poker.Hands.DrawHands

<div class="hand-history-section">
	@if (Entries is not null && Entries.Any())
	{
		<div class="history-list" role="list" aria-label="Hand history">
			@foreach (var entry in Entries.OrderByDescending(e => e.HandNumber))
			{
				var isExpanded = _expandedHandNumbers.Contains(entry.HandNumber);
				
				<div class="history-entry" role="listitem">
					<button class="history-entry-header @(isExpanded ? "expanded" : "")" 
							@onclick="() => ToggleHandExpansion(entry.HandNumber)"
							aria-expanded="@isExpanded"
							title="@(isExpanded ? "Click to collapse" : "Click to expand for player details")">
						<span class="expand-icon">
							<i class="fa-solid @(isExpanded ? "fa-chevron-down" : "fa-chevron-right")" aria-hidden="true"></i>
						</span>
						<span class="hand-number">#@entry.HandNumber</span>
						<span class="winner-info">
							<span class="winner-name" title="@GetWinnerTitle(entry)">
								@(string.IsNullOrWhiteSpace(entry.WinnerName) ? "Unknown" : entry.WinnerName)
							</span>
							@if (entry.WinnerCount > 1)
							{
								<span class="split-indicator">(Split @entry.WinnerCount-way)</span>
							}
						</span>
						<span class="amount-won">+@entry.AmountWon.ToString("N0")</span>
					</button>
					
					@if (isExpanded && entry.PlayerResults.Any())
					{
						<div class="player-results-container">
							<div class="player-results-header">
								<span class="header-player">Player</span>
								<span class="header-result">Result</span>
								<span class="header-hand">Hand</span>
							</div>
							@foreach (var result in entry.PlayerResults)
							{
								<div class="player-result-row @GetResultClass(result)">
									<span class="result-player">@result.PlayerName</span>
									<span class="result-label">@result.ResultLabel (<span class="result-amount">@FormatNetAmount(result.NetAmount)</span>)</span>
									<span class="result-hand">@FormatHand(result.VisibleCards, GetPlayerHandDescription(result, entry))</span>
								</div>
							}
						</div>
					}
				</div>
			}
		</div>
	}
	else
	{
		<div class="history-empty">
			<i class="fa-regular fa-clock-rotate-left" aria-hidden="true"></i>
			<span>No hands played yet</span>
		</div>
	}
</div>

@code {
	/// <summary>
	/// The list of hand history entries to display.
	/// </summary>
	[Parameter]
	public IReadOnlyList<HandHistoryEntryDto>? Entries { get; set; }

	/// <summary>
	/// The game type code (e.g. KINGSANDLOWS) to use for hand evaluation.
	/// </summary>
	[Parameter]
	public string? GameTypeCode { get; set; }

	/// <summary>
	/// Set of hand numbers that are currently expanded.
	/// </summary>
	private readonly HashSet<int> _expandedHandNumbers = [];

	private void ToggleHandExpansion(int handNumber)
	{
		if (_expandedHandNumbers.Contains(handNumber))
		{
			_expandedHandNumbers.Remove(handNumber);
		}
		else
		{
			_expandedHandNumbers.Add(handNumber);
		}
	}

	private static string GetWinnerTitle(HandHistoryEntryDto entry)
	{
		if (entry.WinnerCount > 1)
		{
			return $"{entry.WinnerName} (Split {entry.WinnerCount}-way)";
		}
		return entry.WinnerName;
	}

	private static string GetResultClass(PlayerHandResultDto result)
	{
		return result.ResultType switch
		{
			"Won" => "result-won",
			"SplitPotWon" => "result-split",
			"Lost" => "result-lost",
			"Folded" => "result-folded",
			_ => ""
		};
	}

	private static string FormatNetAmount(int netAmount)
	{
		return netAmount switch
		{
			> 0 => $"+{netAmount:N0}",
			< 0 => netAmount.ToString("N0"),
			_ => "0"
		};
	}

	private static MarkupString FormatHand(IReadOnlyList<string>? visibleCards, string? handDescription)
	{
		if (visibleCards == null || !visibleCards.Any())
		{
			return new MarkupString(string.Empty);
		}

		var cards = string.Join(", ", visibleCards);
		if (!string.IsNullOrWhiteSpace(handDescription))
		{
			return new MarkupString($"{cards}<br/>({handDescription})");
		}
		return new MarkupString(cards);
	}

	private string? GetPlayerHandDescription(PlayerHandResultDto result, HandHistoryEntryDto entry)
	{
		if (result.VisibleCards is not null && result.VisibleCards.Count == 5)
		{
			List<Card>? cards = null;
			try
			{
				cards = result.VisibleCards.Select(vc => vc.ToCard()).ToList();

				HandBase hand = GameTypeCode?.ToUpperInvariant() switch
				{
					"KINGSANDLOWS" => new KingsAndLowsDrawHand(cards),
					"TWOSJACKSMANWITHTHEAXE" => new TwosJacksManWithTheAxeDrawHand(cards),
					_ => new DrawHand(cards)
				};

				return HandDescriptionFormatter.GetHandDescription(hand);
			}
			catch
			{
				// If specialized hand evaluation fails, fallback to standard poker hand evaluation
				if (cards is not null)
				{
					try
					{
						var standardHand = new DrawHand(cards);
						return HandDescriptionFormatter.GetHandDescription(standardHand);
					}
					catch
					{
						// Ignore secondary failure
					}
				}
			}
		}

		if (result.ResultType == "Won" || result.ResultType == "SplitPotWon")
		{
			return entry.WinningHandDescription;
		}

		return null;
	}
}
